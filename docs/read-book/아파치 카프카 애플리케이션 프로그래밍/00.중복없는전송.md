# 적어도 한 번 전송 `at-least-once`
***카프카의 기본 동작 방식***

1. 프로듀서가 브로커의 특정 토픽으로 메시지 A 전송
2. 브로커는 메시지 A 기록, 잘 받았다는 응답으로 ACK 를 프로듀서에게 전송
3. 브로커의 ACK를 받은 프로듀서는 다음 메시지인 메시지 B 브로커에서 전송
4. 브로커는 메시지 B 기록, 잘 받았다는 응답으로 ACK 를 프로듀서에게 전달하려고 했지만, 네트워크 오류나 브로커 장애로 ACK 전달 실패
5. 메시지 B 를 전송한 후 브로커로부터 ACK 를 받지 못 한 프로듀서는 브로커가 메시지 B 를 받지 못했다고 판한하여 재전송
    - 프로듀서 입장에서는 브로커가 메시지 B 를 전달받았는지 알 수 없기 때문에 중복이 발생할 가능성이 있지만 메시지 B 를 재전송하여 적어도 한번은 전송되는 것을 보장

# 최대 한 번 전송 `at-most-once`
일부 메시지가 손실되더라도 높은 처리량을 필요로 하는 대량의 로그 수집 등의 환경에서 사용

1. 프로듀서가 브로커의 특정 토픽으로 메시지 A 전송
2. 브로커는 메시지 A 기록, 잘 받았다는 응답으로 ACK 를 프로듀서에게 전송
3. 프로듀서는 다음 메시지인 메시지 B 를 브로커에게 전송
4. 브로커는 메시지 B 를 기록하지 못하고, 잘 받았다는 ACK 를 전송하지 못했음
5. 프로듀서는 브로커가 메시지 B 를 받았다고 가정하고, 메시지 C를 전송
    - 메시지 B 가 유실되었거나, 네트워크나 브로커의 장애로 ACK 를 전송하지 못했을 수도 있지만 메시지의 중복 가능성을 회피하기 위해 재전송을 하지 않음

# 중복없는 전송(정확히 한 번 전송 `exactly-once`)
1. 프로듀서가 브로커의 특정 토픽으로 메시지 A 전송, PID 0과 메시지 번호 0을 헤더에 포함 (PID:0, 메시지번호:0)
2. 브로커는 메시지 A 저장, PID 와 메시지 번호를 메모리에 기록 후 ACK 를 프로듀서에게 전송
3. 프로듀서는 다음 메시지인 메시지 B 를 브로커에게 전송. PID 는 동일하게 0, 메시지 번호는 1이 증가하여 1 (PID:0, 메시지번호:1)
4. 브로커는 메시지 B 저장, PID와 메시지 번호를 메모리에 기록, ACK 를 전송하지 못함
5. 브로커로부터 ACK를 받지 못한 프로듀서는 브로커가 메시지 B 를 받지 못했다고 판단해 메시지 B를 재전송
    - 브로커는 마지막으로 재전송 된 메시지 B 의 PID, 메시지번호를 확인하여 메시지 B 가 이미 브로커에 저장되어 있는 것을 확인하여 메시지를 중복 저장하지 않고 ACK 만 프로듀서로 전송
