# 아키텍처란
소프트웨어 아키텍트는 프로그래머이며 코드와 동떨어져서는 안된다.  
프로그래밍 작업뿐만 아니라 다른 팀원들이 생산성을 극대화 할 수 있는 설계를 하도록 방향을 이끌어야 한다.  
소프트웨어 시스템의 아키텍처란 시스템을 구축했던 사람들이 만들어낸 시스템의 형태이며 컴포넌트로 분할하는 방법, 분할된 컴포넌트를 배치하는 방법, 컴포넌트가 서로 의사소통하는 방식에 따라 정해진다.  
시스템 아키텍처는 시스템의 동작 여부와는 거의 관련이 없다.  
아키텍처의 주된 목적은 시스템의 생명주기를 지원하는 것이고, 시스템을 쉽게 이해하고 개발하고 유지보수하고 배포하게 한다.  
**궁극적인 목표는 시스템 수명과 관련된 비용을 최소화하고 생산성을 최대화하는 데 있다**

## 개발
팀 구성원과 팀의 구조에 따라 아키텍처를 선택해야 한다  
구성원의 수가 적으면 아키텍처 관련 제약들이 오히려 방해가 될 수 있고, 구성원의 수가 많아지기 시작하면 잘 설계된 컴포넌트 단위로 분리하지 않으면 개발 생산성이 하락할 수 있다

## 배포
- 배포 비용이 높을수록 시스템의 유용성 하락
  - 시스템을 단 한번에 쉽게 배포할 수 있도록 만들어야 함

## 운영
운영을 방해하는 아키텍처가 개발, 배포, 유지보수를 방해하는 아키텍처보다는 비용이 낮음

## 유지보수
유지보수의 가장 큰 비용은 탐사`spelunking`와 이로 인한 위험부담
  - 탐사 : 기존 소프트웨어에 새로운 기능을 추가하거나 결함 수정시 소프트웨어의 어디를 고치는 게 최선인지, 어떤 전략을 쓰는게 최적일지 결정할 때 드는 비용
  - 변경사항 반영시 의도치 않은 결함이 발생할 가능성은 항상 있고, 이로 인해 위험부담 비용이 추가된다

## 선택사항 열어두기
중요하지 않은 세부사항은 가능한 많이, 오래도록 열어두어야 한다 => 결정하지 않아야 한다
- 소프트웨어 시스템은 두 가지 구성요소로 분해 가능 : 정책`policy`, 세부사항`detail`
  - 정책 : 시스템의 진정한 가치가 살아있는 곳
  - 세부사항 : 사람, 외부 시스템, 프로그래머 등이 정책과 소통시 필요한 요소지만 정책의 행위에 영향을 미치지 않음
    - 입출력장치, 데이터베이스, 웹 시스템, 서버, 프레임워크, 통신프로토콜 등등
- 아키텍트의 목표는 시스템에서 정책을 가장 핵심적 요소로 식별 + 세부사항을 정책에 무관하게 만들 수 있는 형태의 시스템 구축
  - 세부사항에 정책이 영향을 받지 않도록 세부사항을 잘 추상화한다. 예를 들면 스프링의 서비스 추상화와 같이 구체적인 사항에 의존할 필요가 없도록 만들어야 한다

**좋은 아키텍트는 결정되지 않은 사항의 수를 최대화한다**

## 결론
좋은 아키텍트는 세부사항을 정책으로부터 신중히 가려내고, 결합되지 않도록 엄격하게 격리하여, 정책이 세부사항에 대해 어떠한 지식도 갖지 않게 하여 의존하지 않도록 해야 한다

# 독립성
좋은 아키텍처가 지원해야 하는 것
  - 시스템의 유스케이스
  - 시스템의 운영
  - 시스템의 개발
  - 시스템의 배포

## 유스케이스
시스템의 아키텍처는 시스템의 의도를 지원해야 함  
좋은 아키텍처를 가진다면 시스템의 구조에서 의도가 드러나고 행위 자체를 설명하는 이름을 갖게 되어 파악하기 쉬운 시스템이 된다

## 운영
아키텍처에서 각 컴포넌트를 잘 격리하고 컴포넌트끼리의 통신방식을 제한하지 않도록 구성하면 운영에 필요한 요구사항이 변경되더라도 기술 스펙트럼을 전환하기 쉬워진다

## 개발
콘웨이의 법칙 작용
> 시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다

각 팀이 독립적으로 행동하기 편한 아키텍처를 확하하여 개발하는 동안 팀간의 독립성을 보장하여야 한다

## 배포
아키텍처는 배포 용이성을 결정하는 데 중요한 역할을 하는 데, 목표를 즉각적인 배포로 잡아야 한다  
시스템이 빌드된 후 즉각 배포할 수 있도록 지원해야 하나다

## 선택사항 열어놓기
선택사항을 열어두어 향후 시스템에 변경이 필요할 때 어떤 방향으로든 쉽게 변경할 수 있도록 해야한다  
우리가 도달하려는 목표는 뚜렷하지 않고 항상 변화하고, 몇가지 아키텍처 원칙을 지킴으로써 시스템의 컴포넌트들을 독립적으로 격리하여 선택사항을 열어둘 수 있도록 한다

## 계층 결합 분리
맥락에 따라서 다른 이유로 변경되는 것들은 분리하고, 동일한 이유로 변경되는 것들은 묶는다  
업무 규칙은 애플리케이션과 밀접한 관련이 있거나, 혹은 더 범용적일 수 있다  
따라서 애플리케이션 자체와 밀접하게 관련된 업무규칙, 업무 도메인에 더 밀접한 업무 규칙 등은 서로 다른 속도로 변경될 수 있다.  
UI, 애플리케이션에 특화된 업무규칙, 애플리케이션과는 독립적인 업무규칙, 데이터베이스 등을 수평적인 계층으로 나누어야 한다.

## 유스케이스 결합 분리
유스케이스는 시스템을 분할하는 매우 자연스러운 방법
  - 각 유스케이스는 다른 속도로 변경된다
  - 주문 추가와 주문 삭제는 다른 속도로 변경되는 유스케이스이다
유스케이스는 시스템의 수평적인 계층을 가로지르도록 수직으로 자른 조각과도 같다  
유스케이스들이 각 수평적 계층에서 서로 겹치지 않도록 해야한다

## 중복
소프트웨어에서 중복은 일반적으로 나쁜 것이다  
중복에는 두 가지 종류가 있는 데, 진짜 중복과 거짓된(우발적) 중복이다  
  - 두 코드의 영역이 각자의 경로로 발전한다면, 즉 서로 다른 속도와 다른 이유로 변경된다면 진짜 중복이 아니다
  - 코드가 중복된 것처럼 보이지만 중복된 경우가 아닐 수 있다. 같거나 비슷한 모양의 코드라 하더라도 다른 속도로 변경될 수 있다면 중복이 아닐 수 있다

중복이 진짜 중복인지 확인하라  
데이터 베이스 레코드를 그대로 UI까지 전달하는 것과 같은 것은 거의 확실히 우발적인 중복이다
  - 뷰 모델을 별도로 UI마다 만드는 것이 계층간 결합을 방지하는 데 더 좋다

## 결합 분리 모드
- 소스 수준 분리 모드
  - 소스 코드 모듈 사이의 의존성을 제어할 수 있다
  - 하나의 모듈이 변해도 다른 모듈을 변경하거나 재컴파일 하지 않음(루비, Gem)
  - 모든 컴포넌트가 같은 주소 공간에서 실행
  - 함수 호출로 통신
  - 모노리틱 구조
- 배포 수준 분리 모드
  - 배포 가능한 단위들 사이의 의존성을 제어할 수 있다
  - 한 모듈이 변해도 다른 모듈들이 재빌드나 재배포를 하지 않음(jar, DLL, 공유라이브러리)
  - 많은 컴포넌트가 같은 주소 공간에서 실행
  - 함수 호출로 통신
  - 동일한 프로세서에서 상주할 수도 있고, 프로세스 간 통신, 소켓, 공유메모리를 통해 통신
  - 독립적으로 배포 가능한 단위로 분할되어 있다
- 서비스 수준 분리 모드
  - 의존하는 수준을 데이터 구조 단위까지 낮출 수 있다
  - 네트워크 패킷을 통해서만 통신
  - 모든 실행 가능한 단위는 소스와 바이너리 변경에 대해 서로 완전히 독립적(서비스 또는 마이크로서비스)

## 결론
처음에는 서비스 수준 분리가 되기 직전까지 모듈들을 분리해두고, 서비스가 확장됨에 따라 판단하여 서비스 수준 분리 모드로 변경할 수 있도록 아키텍처를 설계하는 것이 좋다.  
다시 상황이 바뀌었을 때 진행 방향을 거꾸로 되돌려 모노리틱 구조로 되돌릴 수도 있어야 한다.  
이렇게 바꾸는 것이 쉽지는 않으나 시스템의 결합 분리 모드는 시간이 지남에 따라 항상 변경될 수 있다는 것을 염두에 두고 변경에 대해 예측하여야 한다.
