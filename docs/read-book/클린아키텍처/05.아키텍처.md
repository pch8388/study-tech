# 아키텍처란
소프트웨어 아키텍트는 프로그래머이며 코드와 동떨어져서는 안된다.  
프로그래밍 작업뿐만 아니라 다른 팀원들이 생산성을 극대화 할 수 있는 설계를 하도록 방향을 이끌어야 한다.  
소프트웨어 시스템의 아키텍처란 시스템을 구축했던 사람들이 만들어낸 시스템의 형태이며 컴포넌트로 분할하는 방법, 분할된 컴포넌트를 배치하는 방법, 컴포넌트가 서로 의사소통하는 방식에 따라 정해진다.  
시스템 아키텍처는 시스템의 동작 여부와는 거의 관련이 없다.  
아키텍처의 주된 목적은 시스템의 생명주기를 지원하는 것이고, 시스템을 쉽게 이해하고 개발하고 유지보수하고 배포하게 한다.  
**궁극적인 목표는 시스템 수명과 관련된 비용을 최소화하고 생산성을 최대화하는 데 있다**

## 개발
팀 구성원과 팀의 구조에 따라 아키텍처를 선택해야 한다  
구성원의 수가 적으면 아키텍처 관련 제약들이 오히려 방해가 될 수 있고, 구성원의 수가 많아지기 시작하면 잘 설계된 컴포넌트 단위로 분리하지 않으면 개발 생산성이 하락할 수 있다

## 배포
- 배포 비용이 높을수록 시스템의 유용성 하락
  - 시스템을 단 한번에 쉽게 배포할 수 있도록 만들어야 함

## 운영
운영을 방해하는 아키텍처가 개발, 배포, 유지보수를 방해하는 아키텍처보다는 비용이 낮음

## 유지보수
유지보수의 가장 큰 비용은 탐사`spelunking`와 이로 인한 위험부담
  - 탐사 : 기존 소프트웨어에 새로운 기능을 추가하거나 결함 수정시 소프트웨어의 어디를 고치는 게 최선인지, 어떤 전략을 쓰는게 최적일지 결정할 때 드는 비용
  - 변경사항 반영시 의도치 않은 결함이 발생할 가능성은 항상 있고, 이로 인해 위험부담 비용이 추가된다

## 선택사항 열어두기
중요하지 않은 세부사항은 가능한 많이, 오래도록 열어두어야 한다 => 결정하지 않아야 한다
- 소프트웨어 시스템은 두 가지 구성요소로 분해 가능 : 정책`policy`, 세부사항`detail`
  - 정책 : 시스템의 진정한 가치가 살아있는 곳
  - 세부사항 : 사람, 외부 시스템, 프로그래머 등이 정책과 소통시 필요한 요소지만 정책의 행위에 영향을 미치지 않음
    - 입출력장치, 데이터베이스, 웹 시스템, 서버, 프레임워크, 통신프로토콜 등등
- 아키텍트의 목표는 시스템에서 정책을 가장 핵심적 요소로 식별 + 세부사항을 정책에 무관하게 만들 수 있는 형태의 시스템 구축
  - 세부사항에 정책이 영향을 받지 않도록 세부사항을 잘 추상화한다. 예를 들면 스프링의 서비스 추상화와 같이 구체적인 사항에 의존할 필요가 없도록 만들어야 한다

**좋은 아키텍트는 결정되지 않은 사항의 수를 최대화한다**

## 결론
좋은 아키텍트는 세부사항을 정책으로부터 신중히 가려내고, 결합되지 않도록 엄격하게 격리하여, 정책이 세부사항에 대해 어떠한 지식도 갖지 않게 하여 의존하지 않도록 해야 한다