# 서문
SOLID 원칙이 벽과 방에 벽돌을 배치하는 방법을 알려준다면 컴포넌트 원칙은 빌딩에 방을 배치하는 방법

# 컴포넌트
컴포넌트는 배포 단위다.  
잘 설계된 컴포넌트라면 반드시 독립적으로 배포 가능한, 독립적으로 개발 가능한 능력을 갖춰야 한다.  
컴포넌트 플러그인 아키텍처 : 기존 애플리케이션에 플러그인 형태로 배포하여 붙이는 형태의 아키텍처

# 컴포넌트 응집도
- REP(`Reuse/Release Equivalence Principle`) : 재사용/릴리스 등가 원칙
- CCP(`Common Closure Principle`) : 공통 폐쇄 원칙
- CRP(`Common Reuse Principle`) : 공통 재사용 원칙

## REP : 재사용/릴리스 등가 원칙
**재사용 단위는 릴리스 단위와 같다**
- 단일 컴포넌트는 응집성이 높아야 한다
- 하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리스할 수 있어야 한다
- CCP와 CRP는 REP를 엄격하게, 하지만 제약을 가하는 측면에서 정의한다

## CCP : 공통 폐쇄 원칙
**동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 서로 다른 시점에 다른 이유로 변경되는 것들은 서로 분리하라**
- SRP를 컴포넌트 관점으로 다시 쓴 것
  - 단일 컴포넌트는 변경의 이유가 여러개 있어선 안됨
- 릴리스, 재검증, 배포하는 일과 관련된 작업량을 최소화하는 효과
- OCP와 밀접한 관계가 있음
  - 완전한 폐쇄는 불가능하므로 전략적으로 폐쇄 => 발생할 가능성이 있거나 과거에 발생했던 대다수의 공통적인 변경에 대해서 클래스가 닫혀 있도록 설계
  - 동일한 유형의 변경에 대해 닫혀 있는 클래스들을 하나의 컴포넌트로 묶는다

## CRP : 공통 재사용 원칙
**컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라**
- 클래스와 모듈을 어느 컴포넌트에 위치시킬지 결정시 도움이 되는 원칙
- 의존하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해 의존함을 확실히 인지해야 함
- CRP는 어떤 클래스를 컴포넌트로 묶어도 되는지보다 어떤 클래스를 컴포넌트로 묶어서는 안되는 지에 대해 더 많이 이야기 함
  - 강하게 결합되지 않은 클래스들을 동일한 컴포넌트에 위치시켜서는 안된다

### ISP와의 관계
- CRP는 ISP의 포괄적 버전
**필요하지 않은 것에 의존하지 말라**

## 컴포넌트 응집도에 대한 균형 다이어그램
응집도에 대한 세 원칙은 서로 상충된다
- REP와 CCP는 포함원칙 => 두 원칙은 컴포넌트를 더욱 크게 만듬
- CRP는 배체원칙 => 컴포넌트를 더욱 작게 만듬
<img width="479" alt="component-diagram" src="https://user-images.githubusercontent.com/17218212/157004184-a8284fdf-0570-4b3d-bc31-6445c1fc369d.png">

- 프로젝트 초기에는 CCP가 REP보다 훨씬 중요 => 개발 가능성`developability`이 재사용성보다 더욱 중요하기 때문
- 일반적으로 프로젝트는 삼각형의 오른쪽에서 시작 (재사용성만 희생)
- 프로젝트가 성숙하고, 파생된 프로젝트가 생기기 시작하면 점차 왼쪽으로 이동

## 결론
클래스들을 묶어서 컴포넌트로 만들지 결정할 때 재사용성과 개발 가능성이라는 상충하는 힘을 반드시 고려해야 한다

# 컴포넌트 결합
세 가지 원칙은 컴포넌트 사이의 관계를 설명

## ADP : 의존성 비순환 원칙
**컴포넌트 의존성 그래프에 순환`cycle`이 있어서는 안된다**
- 의존성 순환을 막기 위한 해결책
  - 주 단위 빌드`weekly build`
  - 의존성 비순환 원칙`Acyclic Dependencies Principle, ADP`

### 주 단위 빌드
통합을 주 단위로 하게 되면 결국엔 개발보다 통합에 드는 시간이 점점 많아지게 되어 빌드 일정이 늘어나게 되는 현상을 맞을 수 있다
- 개발 환경을 릴리스 가능한 컴포넌트 단위로 분리해서 해결
  - 컴포넌트는 개별 개발자나 단일 개발팀이 책일질 수 있는 단위가 된다

### 순환 의존성 제거
의존성 구조에 순환이 있어서는 안된다  
의존성 관계는 방향이 있는 간선 => 비순환 방향 그래프 구조를 만들어야 함  
순환이 생기면 컴포넌트 분리가 어려워지고 에러도 쉽게 발생하며, 모듈의 개수가 많아질수록 빌드 관련 이슈는 기하급수적으로 증가한다

### 순환 끊기
1. 의존성 역전 원칙 적용
2. 순환이 생긴 컴포넌트들이 모두 의존하는 새로운 컴포넌트 생성해서 두 컴포넌트에서 의존하는 객체들을 새로운 컴포넌트로 이동

### 흐트러짐(Jitters)
요구사항이 변경되면 컴포넌트 구조도 변경될 수 있다  
의존성 구조는 서서히 흐트러지며 성장 => 항상 의존성 구조에 순환이 발생하는 지 관찰해야 함

## 하향식(top-down) 설계
- 컴포넌트 구조는 하향식으로 설계될 수 없다
  - 컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니며 오히려 시스템이 성장하고 변경될 때 함께 진화
- 컴포넌트 의존성 다이어그램은 애플리케이션의 빌드 가능성`buildability`과 유지보수성`maintainability`을 보여주는 지도와 같다
  - 따라서 컴포넌트 구조를 초기에 설계할 수 없다 => 빌드하거나 유지보수할 소프트웨어가 없다면 지도도 필요없기 때문
- 의존성 구조와 관련된 최우선 관심사는 변동성 격리

## SDP : 안정된 의존성 원칙
**안정성의 방향으로(더 안정된 쪽에)의존하라**
- 변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들면 안된다. 한번 의존하게 되면 변동성이 큰 컴포넌트도 결국 변경이 어려워진다
- 안정된 의존성 원칙`Stable Dependencies Principle, SDP`을 준수하면 변경하기 어려운 모듈이 변경하기 쉽게 만들어진 모듈에 의존하지 않도록 만들 수 있다

### 안정성(stability)
변경을 만들기 위해 필요한 작업량이 많으면 변경하기 쉽지 않기 때문에 안정적이라고 할 수 있다.  
즉, 변경하기 힘들기 때문에 안정적이라고 말한다.  
- 여러 컴포넌트를 책임지면(responsible) 안정된 컴포넌트
  - 책임진다는 것은 다른 컴포넌트가 해당 컴포넌트에게 의존한다는 의미
- 특정 컴포넌트가 다른 컴포넌트를 의존하지 않으면 독립적이다(independent)
- 특정 컴포넌트가 다른 컴포넌트를 의존하면 불안정한 컴포넌트(많이 의존할수록 불안정해진다)
- 어떤 컴포넌트도 해당 컴포넌트를 의존하지 않으면 책임성이 없다고 한다

### 안정성 지표
- Fan-in : 안으로 들어오는 의존성
- Fan-out : 밖으로 나가는 의존성
- I(불안정성) : I = Fan-out / (Fan-in + Fan-out)
  - 이 지표는 [0, 1] 범위의 값을 갖는데 0에 가까울수록 안정된 컴포넌트이고, 1에 가까울수록 불안정한 컴포넌트이다

### 모든 컴포넌트가 안정적이어야 하는 것은 아니다
모든 컴포넌트가 최고로 안정적인 시스템이라면 변경이 불가능하다. 이것은 현실적으로 불가능하며 SDP를 준수하도록 아키텍처를 설계하여야 한다.  
즉, 안정된 컴포넌트에게 불안정한 컴포넌트들이 의존하여야 하고, 안정된 컴포넌트가 불안정한 컴포넌트를 의존해야 하는 경우가 생기면 DIP를 통해 의존성을 역전시켜 해결한다.
- 새로운 컴포넌트를 만들어 인터페이스를 만들고 안정된 컴포넌트는 해당 컴포넌트를 의존하게 하여 SDP를 준수하도록 한다.
- 모든 의존성을 I가 감소하는 방향으로 향하게 한다

## SAP : 안정된 추상화 원칙
**컴포넌트는 안정된 정도만큼만 추상화되어야 한다**  
안정된 추상화원칙`Stable Abstraction Principle, SAP`은 안정성과 추상화 사이의 관계를 정의하는 원칙이다.  
고수준 아키텍처나 정책 결정과 관련된 소프트웨어는 시스템에서 자주 변경해서는 절대로 안되는 것인데, 그렇기 때문에 안정된 컴포넌트로 위치시켜야 한다.  
하지만, 이렇게 안정된 컴포넌트로 위치시키면 해당 정책과 관련된 소스 코드들은 수정이 어려워지고 시스템 전체 아키텍처가 유연성을 잃을 수 있다.  
컴포넌트가 안정된 상태이면서도 변경에 유연하게 대응하기 위해서는 OCP와 같은 원칙을 적용해야 한다.  
이 원칙에서는 추상화를 통해 문제를 해결하도록 추천하는 데, 이것은 안정된 컴포넌트일수록 인터페이스와 추상클래스로 구성하여 쉽게 확장할 수 있도록 해야한다는 것이다.  