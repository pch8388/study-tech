# 서문
SOLID 원칙이 벽과 방에 벽돌을 배치하는 방법을 알려준다면 컴포넌트 원칙은 빌딩에 방을 배치하는 방법

# 컴포넌트
컴포넌트는 배포 단위다.  
잘 설계된 컴포넌트라면 반드시 독립적으로 배포 가능한, 독립적으로 개발 가능한 능력을 갖춰야 한다.  
컴포넌트 플러그인 아키텍처 : 기존 애플리케이션에 플러그인 형태로 배포하여 붙이는 형태의 아키텍처

# 컴포넌트 응집도
- REP(`Reuse/Release Equivalence Principle`) : 재사용/릴리스 등가 원칙
- CCP(`Common Closure Principle`) : 공통 폐쇄 원칙
- CRP(`Common Reuse Principle`) : 공통 재사용 원칙

## REP : 재사용/릴리스 등가 원칙
**재사용 단위는 릴리스 단위와 같다**
- 단일 컴포넌트는 응집성이 높아야 한다
- 하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리스할 수 있어야 한다
- CCP와 CRP는 REP를 엄격하게, 하지만 제약을 가하는 측면에서 정의한다

## CCP : 공통 폐쇄 원칙
**동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 서로 다른 시점에 다른 이유로 변경되는 것들은 서로 분리하라**
- SRP를 컴포넌트 관점으로 다시 쓴 것
  - 단일 컴포넌트는 변경의 이유가 여러개 있어선 안됨
- 릴리스, 재검증, 배포하는 일과 관련된 작업량을 최소화하는 효과
- OCP와 밀접한 관계가 있음
  - 완전한 폐쇄는 불가능하므로 전략적으로 폐쇄 => 발생할 가능성이 있거나 과거에 발생했던 대다수의 공통적인 변경에 대해서 클래스가 닫혀 있도록 설계
  - 동일한 유형의 변경에 대해 닫혀 있는 클래스들을 하나의 컴포넌트로 묶는다

## CRP : 공통 재사용 원칙
**컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라**
- 클래스와 모듈을 어느 컴포넌트에 위치시킬지 결정시 도움이 되는 원칙
- 의존하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해 의존함을 확실히 인지해야 함
- CRP는 어떤 클래스를 컴포넌트로 묶어도 되는지보다 어떤 클래스를 컴포넌트로 묶어서는 안되는 지에 대해 더 많이 이야기 함
  - 강하게 결합되지 않은 클래스들을 동일한 컴포넌트에 위치시켜서는 안된다

### ISP와의 관계
- CRP는 ISP의 포괄적 버전
**필요하지 않은 것에 의존하지 말라**

## 컴포넌트 응집도에 대한 균형 다이어그램
응집도에 대한 세 원칙은 서로 상충된다
- REP와 CCP는 포함원칙 => 두 원칙은 컴포넌트를 더욱 크게 만듬
- CRP는 배체원칙 => 컴포넌트를 더욱 작게 만듬
![component diagram](../../images/component-diagram.png)

- 프로젝트 초기에는 CCP가 REP보다 훨씬 중요 => 개발 가능성`developability`이 재사용성보다 더욱 중요하기 때문
- 일반적으로 프로젝트는 삼각형의 오른쪽에서 시작 (재사용성만 희생)
- 프로젝트가 성숙하고, 파생된 프로젝트가 생기기 시작하면 점차 왼쪽으로 이동

## 결론
클래스들을 묶어서 컴포넌트로 만들지 결정할 때 재사용성과 개발 가능성이라는 상충하는 힘을 반드시 고려해야 한다

# 컴포넌트 결합
세 가지 원칙은 컴포넌트 사이의 관계를 설명

## ADP : 의존성 비순환 원칙
**컴포넌트 의존성 그래프에 순환`cycle`이 있어서는 안된다**
- 의존성 순환을 막기 위한 해결책
  - 주 단위 빌드`weekly build`
  - 의존성 비순환 원칙`Acyclic Dependencies Principle, ADP`

### 주 단위 빌드
통합을 주 단위로 하게 되면 결국엔 개발보다 통합에 드는 시간이 점점 많아지게 되어 빌드 일정이 늘어나게 되는 현상을 맞을 수 있다
- 개발 환경을 릴리스 가능한 컴포넌트 단위로 분리해서 해결
  - 컴포넌트는 개별 개발자나 단일 개발팀이 책일질 수 있는 단위가 된다

### 순환 의존성 제거
의존성 구조에 순환이 있어서는 안된다  
의존성 관계는 방향이 있는 간선 => 비순환 방향 그래프 구조를 만들어야 함  
순환이 생기면 컴포넌트 분리가 어려워지고 에러도 쉽게 발생하며, 모듈의 개수가 많아질수록 빌드 관련 이슈는 기하급수적으로 증가한다

### 순환 끊기
1. 의존성 역전 원칙 적용
2. 순환이 생긴 컴포넌트들이 모두 의존하는 새로운 컴포넌트 생성해서 두 컴포넌트에서 의존하는 객체들을 새로운 컴포넌트로 이동

### 흐트러짐(Jitters)
요구사항이 변경되면 컴포넌트 구조도 변경될 수 있다  
의존성 구조는 서서히 흐트러지며 성장 => 항상 의존성 구조에 순환이 발생하는 지 관찰해야 함

## 하향식(top-down) 설계
- 컴포넌트 구조는 하향식으로 설계될 수 없다
  - 컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니며 오히려 시스템이 성장하고 변경될 때 함께 진화
- 컴포넌트 의존성 다이어그램은 애플리케이션의 빌드 가능성`buildability`과 유지보수성`maintainability`을 보여주는 지도와 같다
  - 따라서 컴포넌트 구조를 초기에 설계할 수 없다 => 빌드하거나 유지보수할 소프트웨어가 없다면 지도도 필요없기 때문
- 의존성 구조와 관련된 최우선 관심사는 변동성 격리

## SDP : 안정된 의존성 원칙
**안정성의 방향으로(더 안정된 쪽에)의존하라**
- 변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들면 안된다. 한번 의존하게 되면 변동성이 큰 컴포넌트도 결국 변경이 어려워진다
- 안정된 의존성 원칙`Stable Dependencies Principle, SDP`을 준수하면 변경하기 어려운 모듈이 변경하기 쉽게 만들어진 모듈에 의존하지 않도록 만들 수 있다