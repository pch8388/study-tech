# 서문
좋은 소프트웨어 시스템은 clean code 로부터 시작  
모듈 수준에서 SOLID 적용

## SOLID 원칙의 목적
- 변경에 유연
- 이해하기 쉬움
- 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반

# SRP : 단일 책임 원칙
단 하나의 일만 해야한다는 원칙은 함수에 적용되는 것 => 이것은 SRP 가 아님

## 정의
하나의 모듈은 오직 하나의 액터에 대해서만 책임져야 한다
- 모듈 : 가장 단순한 정의는 소스 파일
- 응집성(`cohesion`) : 단일 액터를 책임지는 코드를 함께 묶어주는 힘

> SRP 는 서로 다른 액터가 의존하는 코드를 서로 분리하라고 한다

## 결론
- 단일 책임 원칙은 메서드와 클래스 수준의 원칙이지만 더 상위의 수준에서도 다른 형태로 등장
하나의 액터에 대해 책임지기 위해 public interface 가 적을수록 응집도가 올라간다고 생각된다.  
따라서 public method 를 하나만 가지는 것이 이상적이라고 생각은 되지만, 현실적으로는 반드시 지킬만한 원칙은 아닌 것 같다.  
책에서는 각 클래스 자체가 하나의 유효범위가 된다고 설명한다.

# OCP : 개방 - 폐쇄 원칙
소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다  
- 소프트웨어 개체의 행위는 확장할 수 있어야 하지만 이때 개체를 변경하지 않아야 한다
- 소프트웨어 아키텍처를 공부하는 가장 근본적인 이유
- 아키텍처 컴포넌트 수준에서 OCP 를 고려할 때 훨씬 중요한 의미를 지님

## 보호의 계층구조
- A 컴포넌트에서 발생한 변경으로부터 B 컴포넌트를 보호하려면 반드시 A 컴포넌트가 B 컴포넌트에 의존해야 한다
- 보호의 계층구조는 level 개념을 바탕으로 생성될 수 있는 데, 가장 높은 수준의 개념이 최고의 보호를 받고, 낮은 수준의 개념일 수록 보호를 받지 못한다.
- 컴포넌트 계층구조를 조직화하면 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있다.

## 정보은닉
추이 종송석을 가지게 되면 `자신이 직접 사용하지 않는 요소에는 절대로 의존해서는 안된다`는 소프트웨어 원칙을 위반하게 됨

## 결론
시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조를 만들어야 한다.  
이를 위해 DIP 와 같은 기법을 사용하여 의존성을 끊어내고, 컴포넌트들이 서로 영향을 받지 않도록 추상적인 인터페이스에 의존하도록 하여 의존성의 방향을 바꿔야 한다.

# LSP : 리스코프 치환 원칙
A객체를 B객체로 치환하더라도 해당 프로그램에서 `행위`가 변경되지 않으면 B는 A의 하위 타입이다.  
객체를 사용하는 액터의 행위가 사용하는 타입 자체에 의존하면 타입을 치환할 수 없게 된다.

## 결론
LSP는 아키텍처 수준까지 확장해야한다.  
치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 메커니즈므을 추가해야 할 수 있기 때문이다.