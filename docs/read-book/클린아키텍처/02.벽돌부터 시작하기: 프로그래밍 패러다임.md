# 패러다임의 개요
- 구조적 프로그래밍은 제어흐름의 직접적인 전환에 대해 규칙을 부과
- 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과
- 함수형 프로그래밍은 할당문에 대해 규칙을 부과

> 각 패러다임은 프로그래머에게서 권한을 박탈한다. 즉, 패러다임은 무엇을 해야할지보다는 무엇을 해서는 안되는지를 말해준다.

- 세 가지 패러다임은 각각 goto문, 함수 포인터, 할당문을 앗아감
- 더이상 제한할 것이 없기 때문에 프로그래밍 패러다임이 더이상 생겨나지 않을 것이다

# 구조적 프로그래밍
- 모듈을 분해할 수 없다면, 합리적 증명의 필수 기법인 분할 정복 접근법을 사용할 수 없음
- 모든 프로그램은 순차, 분기, 반복의 세가지 구조만으로 표현 가능

## 기능적 분해
- 구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해
  - 모듈을 기능적으로 분해할 수 있음
- 거대한 문제 -> 고수준의 기능들로 분해 -> 각 기능을 다시 저수준 함수로 분해 -> 재귀적 반복
- 구조적 분석`structured analysis` / 구조적 설계`structured design`
  - 대규모 시스템을 모듈과 컴포넌트로 나눌 수 있고, 모듈과 컴포넌트는 입증 가능한 아주 작은 기능으로 세분화 할 수 있음

## 테스트
- 테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수 없음
- 테스트가 보장하는 것은 프로그램이 목표에 부합할 만큼 충분히 참이라고 여길 수 있게 해주는 것
- **소프트웨어는 과학과 같다. 최선을 다해도 올바르지 않음을 증명하는 데 실패함으로써 올바름을 보여준다**

## 결론
- 구조적 프로그래밍의 가치는 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 능력
  - 아키텍처 관점에서 기능적 분해를 최고의 실천법 중 하나로 여기는 이유
- 소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록(테스트하기 쉽도록) 만들기 위해 노력해야 함

# 객체 지향 프로그래밍
좋은 아키텍처를 만드는 일은 객체지향 설계 원칙을 이해하고 응용하는 데서 출발

## 캡슐화
- 데이터와 함수를 쉽고 효과적으로 캡슐화 하는 방법을 객체지향언어가 제공
- 많은 객체지향 언어가 캡슐화를 거의 강제하지 않는다 (Python, JavaScript, Lua, Ruby...)

## 상속
상속이란 단순히 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 일

## 다형성
- 행위가 타입에 의존하는 것
- 함수를 가리키는 포인터를 응용한 것
  - 함수 포인터를 직접적으로 사용하는 것은 위험하기 때문에 객체지향 언어에서는 이를 직접사용하지 않도록 참조를 지원한다

## 의존성 역전
- 일반적으로 제어흐름은 시스템의 행위에 따라 결정되며, 소스코드 의존성은 제어흐름에 따라 결정된다
- 의존성 역전으로 통해 소스코드 의존성이 제어흐름과 반대로 흐르도록 한다
- 배포 독립성 : 특정 컴포넌트의 소스 코드 변경시 해당 코드가 포함된 컴포넌트만 다시 배포
- 개발 독립성 : 시스템의 모듈을 독립적으로 배포할 수 있기 때문에, 모듈을 각자 독립적으로 개발

## 결론
객체지향이란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득하는 능력

# 함수형 프로그래밍
- 함수형 언어에서 변수는 변경되지 않음

## 불변성과 아키텍처
- race condition, deadlock, concurrent update 등의 문제는 모두 가변 변수로 인해 발생
- 동시성에 관한 문제는 가변변수가 없다면 생기지 않음
- 불변성은 실현 가능하지만 일종의 현실적 타협이 필요

## 가변성의 분리
- 타협 중 하나는 애플리케이션이나 애플리케이션 내부를 가변 컴포넌트와 불변 컴포넌트로 분리하는 것
- 가변 컴포넌트와 불변 컴포넌트를 분리하고 가능하면 가변 컴포넌트의 규모를 줄여야 함

## 이벤트 소싱
- 저장공간과 처리능력의 한계가 줄어듬에 따라 이벤트 소싱과 같은 방법이 등장
- 상태가 아닌 트랙잭션을 저장하는 전략
  - 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션 처리
- 애플리케이션은 CRUD가 아닌 CR만 수행
- 소스 코드 버전관리 시스템이 이런 방식으로 동작

## 결론
- 세가지의 패러다임은 모두 무언가를 제한한다
- 소프트웨어는 순차, 분기, 반복, 참조로 구성된다. 그 이상도 이하도 아니다.