# 동기화
동기화를 통해 복제 셋에 동일한 데이터 복사본을 유지
- 기본 작업이 수행하는 모든 쓰기(CUD)를 포함하는 작업로그 혹은 oplog를 유지
  - 프라이머리의 `local` 데이터베이스에 있는 제한된 컬렉션에 저장
  - 세컨더리는 복제할 작업에 대해 이 컬렉션을 조회
- 각 세컨더리는 자체 `oplog`를 유지/관리하고 프라이머리에서 복제하는 각 작업을 기록
  - 작업 적용이 실패하면 세컨더리가 종료된다
  - 세컨더리가 다운되면 재시작 시 `oplog`의 마지막 작업을 기준으로 동기화 시작
  - oplog 의 작업을 동기화(재실행)하는 것은 멱등성을 가진다

## oplog
- 기본적으로 고정된 크기로 특정 수의 작업만 보유 가능
- 데이터를 쓰는 속도와 거의 같은 속도로 `oplog`가 기록됨
  - 단, 삭제는 데이터를 지우기 때문에, `oplog`만 기록
- oplog 사이즈가 커야 하는 경우
  - 한 번에 여러 문서 업데이트
  - 삽입한만큼 삭제하는 경우
  - 도큐먼트 업데이트가 잦은 경우
- 레플리카 셋 구성시 `oplogSizeMB` 옵션으로 사이즈를 지정할 수 있다
- 이미 레플리카 셋이 구성되어 있다면 직접 레플라키 셋 멤버에 접근하여 수정해야 한다 [참고](https://docs.mongodb.com/manual/tutorial/change-oplog-size/)
  ```javascript
  // 세컨더리 쉘 접속 후
  // local db 사용
  use local
  // 현재 oplog 사이즈 확인
  db.oplog.rs.stats().maxSize
  // 변경 (예제는 16000MB)
  db.adminCommand({replSetResizeOplog:1, size:Double(16000)})
  ```

## 초기 동기화(Initial Sync)
레플리카 셋의 한 구성원에서 다른 구성원으로 모든 데이터를 복사

### 초기 동기화 과정
1. `local` 데이터베이스를 제외한 모든 데이터베이스 복제
2. `mongod`는 대상 멤버에게 복사할 데이터베이스의 모든 컬렉션과 데이터를 검색
3. 대상 멤버의 모든 데이터를 삭제
4. 데이터 복제
5. `mongod`는 복사 중 발생한 데이터에 대한 변경사항에 대한 `oplog`를 사용하여 대상 멤버에 적용

> 백업에서 복원하여 초기화 하는 것이 속도가 더 빠름

## Replication
세컨더리는 초기화 후 지속적으로 데이터를 복제한다  
동기화 소스에서 `oplog`를 복사하고 비동기 프로세스에서 적용

## 부실처리
- 세컨더리가 동기화 소스에서 수행되는 실제 작업보다 너무 뒤떨어지면, 세컨더리는 `stale`상태가 됨
  - 동기화 소스의 `oplog`에 있는 작업과 세컨더리의 작업이 너무 차이나면 모든 오퍼레이션을 수행하며 따라 잡을 수가 없어서 작업을 누락시킬 수 있음
- 세컨더리가 `stale`상태가 되었을 때 레플리카 셋의 각 구성원에서 차례로 복제를 시도하여 부트스트랩 => 가장 긴 `oplog`를 찾음
  - 충분히 긴 `oplog`를 가진 멤버가 없으면 복제를 중지하고 완전히 재동기화해야함
- `stale`상태를 피하려면 `oplog`사이즈를 충분히 크게 만들면 된다
  - `oplog`사이즈가 크더라도 `oplog`를 자주 사용할 일이 적기 때문에 메모리에 잘 올리지 않아 메모리 효율을 떨어뜨릴 가능성은 적다
  - 2~3일 동안의 정상작업에 대해 저장

# Heartbeats
다른 멤버의 상태를 알기 위해 전송하는 신호 : 프라이머리 멤버, 동기화 가능 멤버, 다운된 멤버 확인
- 2초에 한번 다른 멤버에게 모두 전송
- 프라이머리가 복제셋의 과반수 이상의 멤버와 연결되지 않는 지 확인 => 과반수 이상과 연결되지 않으면 세컨더리로 강등 시킴

## 멤버 상태
기본적으로 프라이머리와 세컨더리로 나눌 수 있지만, 그 외에 자주 볼 수 있는 상태가 있음
- STARTUP : 처음 시작시 레플리카 셋 설정정보를 로딩 중인 상태, 처음 설정정보가 로드되면 `STARTUP2` 상태로 변경
- STARTUP2 : 초기 동기화 프로세스동안 지속되는 상태, 복제 및 선출을 처리하기 위해 두 개의 프로세스로 분기한 다음 `RECOVERING` 상태로 변경
- RECOVERING : 명령을 정상적으로 처리할 수 있지만 읽을 수 없는 상태
  - 세컨더리가 되기 전에 유효한 상태인지 확인하기 위해 이 상태를 거침
  - 압축과 같이 오래걸리는 작업을 수행할 때나 `replSetMaintenance` 명령의 결과로 이 상태가 될 수 있음
- [ARBITER](https://github.com/pch8388/pch8388.github.io/blob/master/docs/read-book/%EB%AA%BD%EA%B3%A0DB%20%EC%99%84%EB%B2%BD%20%EA%B0%80%EC%9D%B4%EB%93%9C/10.%EB%B3%B5%EC%A0%9C%20%EC%85%8B%20%EC%84%A4%EC%A0%95.md#%EC%95%84%EB%B9%84%ED%84%B0-%EC%84%A0%EC%B6%9C) : 프라이머리 선출에 참여하는 용도로만 사용

시스템에 문제가 생긴 것을 알리는 상태
- DOWN : 멤버가 작동 중이었으나 연결할 수 없게 된 상태 => 네트워크 문제
- UNKNOWN : 하트비트 통신이 되지 않아 정확한 원인을 알 수 없음
- REMOVED : 레플리카 셋에서 멤버가 제거됨
- ROLLBACK : 멤버가 데이터를 롤백할 경우

## 프라이머리 선출 방법
- 세컨더리가 스스로 프라이머리가 될 것을 요청하는 데, 아래의 항목을 토대로 검사 수행
  - 요청받은 멤버가 프라이머리에 도달할 수 있는지
  - 선출되고자 하는 멤버의 복제 데이터가 최신인지
  - 다른 우선순위(priority)가 더 높은 멤버가 없는지
- 선출과정
  1. 복제 셋 멤버는 2초바다 하트비트(heartbeat, ping)을 보냄
  2. 10초 이내에 멤버가 하트비트를 보내지 않으면 다른 멤버가 해당 멤버를 접근할 수 없는 걸로 표시
  3. 선출 알고리즘은 우선순위가 가장 높은 세컨더리가 선출을 호출할 수 있도록 노력(?)
  4. 우선순위가 더 낮은 세컨더리가 프라이머리가 잠시 될 수 있지만 가장 우선순위가 높은 세컨더리가 프라이머리가 될 때까지 계속해서 과정을 반복
- 프라이머리로 선출되려면 복제데이터가 최신이어야 함
  - OpLog의 마지막 시간(lastOpTime)을 체크하여 동기화가 다 된것을 확인하고 선출된다 
- 프라이머리 멤버 선출에 참여할 수 있는 레플리카 셋의 멤버는 7개까지만 가능
  - 레플리카 셋에 더 많은 멤버를 참여 시킬 수 있지만 프라이머리 선출 과정에 드는 리소스를 줄이기 위해 7개까지만 참여시킴
  - 레플리카 셋 멤버가 7개를 초과하면 이후에 추가되는 멤버들은 Non-Voting 멤버여야 한다
- 스플릿 브레인(Split-brain) : 멤버 간에 네트워크 연결이 끊어졌지만 프라이머리는 여전히 정상상태여서 사용자의 요청을 처리하는 현상
  - 스플릿 브레인을 막기 위해 전체의 과반수 멤버와 통신이 되지 않으면 자동으로 프라이머리에서 세컨더리 멤버로 강등
  - 이러한 현상때문에 자가선출(Self-Election) 방법을 채택

### 세컨더리가 프라이머리를 투표할 때 고려하는 점
- 후보가 현재 투표자와 같은 레플리카 셋 멤버인지
- 후보의 우선순위가 현재 레플리카 셋에 있는 다른 모든 멤버보다 높은지
- 후보가 요청한 투표의 텀(Term)에 투표자가 투표한적이 없는지
- 후보자가 요청한 투표의 텀(Term)이 투표자가 이제까지 참여한 투표의 텀보다 큰 값인지
- 후보자가 투표자보다 더 최신 데이터를 갖고 있거나 동등한 데이터를 갖고 있는지(OpLog의 OpTime이 더 최신이거나 같은지)

### 프라이머리 선출시 정족수(Quorum)
레플리카 셋의 각 멤버는 `votes` 옵션의 값으로 0 또는 1을 가질 수 있음  
`votes` 옵션이 0인 멤버는 `Non-Voting` 멤버로 프라이머리 선출 시 정족수를 판단하는 기준에 미포함  
투표권을 가진 멤버들 중 `PRIMARY, SECONDARY, RECOVERING, ARBITER, ROLLBACK` 상태를 가진 경우에만 투표 가능
- `STARTUP` : 데이터를 가지지 않은 세컨더리가 프라이머리로부터 초기 동기화를 수행하는 중인 멤버
- `Unreachable` : 하트비트 통신이 되지 않는 상태

### 롤백
레플리카 셋 멤버끼리 동기화하는 과정에서 이미 저장된 데이터를(디스크 영구기록 or 저널로그까지 기록) 다시 삭제하는 과정
- 롤백 과정을 거치면서 삭제되거나 변경된 도큐먼트들은 몽고디비 데이터 디렉터리의 `rollback` 디렉터리에 저장
  - 필요한 재처리 작업을 이를 통해 수행