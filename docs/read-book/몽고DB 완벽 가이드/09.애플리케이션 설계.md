# 스키마 설계 고려 사항
- 애플리케이션에서 요구하는 데이터의 형태로 설계하는 것이 가장 좋은 방법
- RDB와는 달리 스키마 모델링보다 query 및 data access pattern 을 분석해야 한다

## 스키마 설계시 고려할 주요 요소
- 제약사항
  - 도큐먼트의 최대 크기는 16MB
  - 디스크에서 전체 도큐먼트를 읽고 씀 => update는 전체 도큐먼트를 다시 쓰고, atomit update 는 도큐먼트 레벨로 이루어진다
- 쿼리 및 쓰기의 접근 패턴
  - 읽기와 쓰기 빈도를 파악하고, 어떤 쿼리가 가장 많이 실행될지 파악해야 한다
- 관계 유형
  - 애플리케이션 요구 사항과 도큐먼트 관계를 파악하여 데이터나 도큐먼트를 내장하거나 참조할 방법을 결정
- 카디널리티
  - 개체가 개별적으로 접근되는지 혹은 상위 개체의 컨텍스트에서만 접근되는지 등에 대해 고려해야 하고, 해당 데이터 필드에 대한 읽기 갱신 비율도 고려해야 한다
    - 이러한 문제에 대한 답이 도큐먼트 간에 데이터를 비정규화할지, 도큐먼트를 내장하거나 참조할지 결정하는 데 도움이 된다

## 스키마 설계 패턴
[참고](https://www.mongodb.com/blog/post/building-with-patterns-a-summary)

### 다형성 패턴
컬렉션 내 도큐먼트들이 구조가 비슷하지만 동일하지 않은 경우 => 공통 필드가 다수 있는 경우

### 속성 패턴
- 속성패턴 사용하는 경우
  1. 정렬하거나 쿼리하려는 도큐먼트에 필드의 서브셋이 있는 경우
  2. 정렬하려는 필드가 도큐먼트의 서브셋에만 존재하는 경우
  3. 1, 2 모두 해당하는 경우

```javascript
// release 날짜를 검색하기 위해서는 여러 필드를 살펴보아야 함
{
    title: "Star Wars",
    director: "George Lucas",
    ...
    release_US: ISODate("1977-05-20T01:00:00+01:00"),
    release_France: ISODate("1977-10-19T01:00:00+01:00"),
    release_Italy: ISODate("1977-10-20T01:00:00+01:00"),
    release_UK: ISODate("1977-12-27T01:00:00+01:00"),
    ...
}

// 정보의 서브셋을 배열로 만드르어 인덱싱 요구사항을 줄임
{
    title: "Star Wars",
    director: "George Lucas",
    ...
    releases: [
        {
        location: "USA",
        date: ISODate("1977-05-20T01:00:00+01:00")
        },
        {
        location: "France",
        date: ISODate("1977-10-19T01:00:00+01:00")
        },
        {
        location: "Italy",
        date: ISODate("1977-10-20T01:00:00+01:00")
        },
        {
        location: "UK",
        date: ISODate("1977-12-27T01:00:00+01:00")
        },
        ...
    ],
    ...
}

// 인덱스를 만들어 쿼리 효율을 높일 수 있음
{ "releases.location": 1, "releases.date": 1}
```

### 버킷 패턴
- 일정 기간동안 스트림으로 유입되는 시계열 데이터에 적합
- 시간 데이터 등을 일정하게 나누어 버킷화하면 효과적으로 사용

```javascript
{
    sensor_id: 12345,
    start_date: ISODate("2019-01-31T10:00:00.000Z"),
    end_date: ISODate("2019-01-31T10:59:59.000Z"),
    measurements: [
       {
       timestamp: ISODate("2019-01-31T10:00:00.000Z"),
       temperature: 40
       },
       {
       timestamp: ISODate("2019-01-31T10:01:00.000Z"),
       temperature: 40
       },
       ...
       {
       timestamp: ISODate("2019-01-31T10:42:00.000Z"),
       temperature: 42
       }
    ],
   transaction_count: 42,
   sum_temperature: 2413
}
```

### 이상치 패턴
- 드물게 도큐먼트의 쿼리가 애플리케이션의 정상적인 패턴을 벗어날 때 사용
- flag를 사용해(사용자가 지정한 키) 해당 도큐먼트가 outlier 임을 나타내고, 애플리케이션에서 추가 검색을 하도록 처리할 수 있다

### 계산된 패턴
- 데이터가 자주 계산하거나 access pattern 이 읽기에 치중되었을 때 사용
- 특정 시간 별로 미리 계산(집계)를 해두어 cpu 리소스를 낭비하지 않도록 하는 패턴
  - 어떤 형태로 미리 집계할지에 대해서는 애플리케이션 개발자가 정하는 것이 좋다

### 서브셋 패턴
몽고DB는 working set을 RAM에 보관하는데, 이 데이터의 용량이 할당된 물리적 RAM을 초과하면 디스크 액서스가 시작되고 성능이 저하된다. 
이러한 현상은 애플리케이션에서 자주 사용하지 않는 대용량 도큐먼트로 인해 발생할 수 있는 데, 이를 방지하기 위해 서브셋 패턴을 사용한다.
- 자주 사용하는 데이터와 자주 사용하지 않는 데이터를 두 개의 개별 컬렉션으로 분할

> working set : 몽고DB가 가장 자주 사용하는 데이터 집합

### 확장된 참조 패턴
특정 기능을 위해 JOIN 작업이 다소 많이 필요한 경우에 고려해볼 수 있음
- JOIN으로 참조하는 대신 자주 액세스하는 필드만 복사해온다
- 데이터가 중복될 수 있다

### 근사 패턴
리소스가 많이 드는 계산이 필요하지만 정확도가 높지 않아도 되는 상황에 유용
- 카운팅을 하는 작은 컬렉션을 만들고, 특정 수치가 될때마다 원본 도큐먼트를 갱신하는 방식으로 사용 가능

### 트리 패턴
계층적인 데이터가 있을 때 적용
- `$graphLookUp` 과 같은 연산자를 사용할 수도 있음 => 쿼리에 소요되는 리소스가 많을 경우 트리패턴을 고려해볼 수 있음. 혹은 도큐먼트에서 `$graphLookUp` 사용 빈도가 높은 경우
- 다중조인을 피할 수 있지만 그래프에 대한 갱신을 관리해야 함

### 사전 할당 패턴
나중에 채워질 빈 구조를 사전 할당
- 과거의 MMAP 스토리지 엔진 사용시 많이 사용되던 패턴

### 도큐먼트 버전 관리 패턴
도큐먼트에 버전제어 기능이 필요할 때 적용
- 사용하기 적합한 경우
  1. 각 도큐먼트의 수정본이 너무 많지 않은 경우(각 도큐먼트마다 버전이 너무 많이 생성되지 않아야 함)
  2. 버전을 지정할 도큐먼트의 숫자가 너무 많지 않은 경우
  3. 수행되는 대부분의 쿼리는 도큐먼트의 최신 버전에서 수행
