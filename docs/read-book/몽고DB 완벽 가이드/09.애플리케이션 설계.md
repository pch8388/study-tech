# 스키마 설계 고려 사항
- 애플리케이션에서 요구하는 데이터의 형태로 설계하는 것이 가장 좋은 방법
- RDB와는 달리 스키마 모델링보다 query 및 data access pattern 을 분석해야 한다

## 스키마 설계시 고려할 주요 요소
- 제약사항
  - 도큐먼트의 최대 크기는 16MB
  - 디스크에서 전체 도큐먼트를 읽고 씀 => update는 전체 도큐먼트를 다시 쓰고, atomic update 는 도큐먼트 레벨로 이루어진다
- 쿼리 및 쓰기의 접근 패턴
  - 읽기와 쓰기 빈도를 파악하고, 어떤 쿼리가 가장 많이 실행될지 파악해야 한다
- 관계 유형
  - 애플리케이션 요구 사항과 도큐먼트 관계를 파악하여 데이터나 도큐먼트를 내장하거나 참조할 방법을 결정
- 카디널리티
  - 개체가 개별적으로 접근되는지 혹은 상위 개체의 컨텍스트에서만 접근되는지 등에 대해 고려해야 하고, 해당 데이터 필드에 대한 읽기 갱신 비율도 고려해야 한다
    - 이러한 문제에 대한 답이 도큐먼트 간에 데이터를 비정규화할지, 도큐먼트를 내장하거나 참조할지 결정하는 데 도움이 된다

## 스키마 설계 패턴
[참고](https://www.mongodb.com/blog/post/building-with-patterns-a-summary)

### 다형성 패턴
컬렉션 내 도큐먼트들이 구조가 비슷하지만 동일하지 않은 경우 => 공통 필드가 다수 있는 경우

### 속성 패턴
- 속성패턴 사용하는 경우
  1. 정렬하거나 쿼리하려는 도큐먼트에 필드의 서브셋이 있는 경우
  2. 정렬하려는 필드가 도큐먼트의 서브셋에만 존재하는 경우
  3. 1, 2 모두 해당하는 경우

```javascript
// release 날짜를 검색하기 위해서는 여러 필드를 살펴보아야 함
{
    title: "Star Wars",
    director: "George Lucas",
    ...
    release_US: ISODate("1977-05-20T01:00:00+01:00"),
    release_France: ISODate("1977-10-19T01:00:00+01:00"),
    release_Italy: ISODate("1977-10-20T01:00:00+01:00"),
    release_UK: ISODate("1977-12-27T01:00:00+01:00"),
    ...
}

// 정보의 서브셋을 배열로 만드르어 인덱싱 요구사항을 줄임
{
    title: "Star Wars",
    director: "George Lucas",
    ...
    releases: [
        {
        location: "USA",
        date: ISODate("1977-05-20T01:00:00+01:00")
        },
        {
        location: "France",
        date: ISODate("1977-10-19T01:00:00+01:00")
        },
        {
        location: "Italy",
        date: ISODate("1977-10-20T01:00:00+01:00")
        },
        {
        location: "UK",
        date: ISODate("1977-12-27T01:00:00+01:00")
        },
        ...
    ],
    ...
}

// 인덱스를 만들어 쿼리 효율을 높일 수 있음
{ "releases.location": 1, "releases.date": 1}
```

### 버킷 패턴
- 일정 기간동안 스트림으로 유입되는 시계열 데이터에 적합
- 시간 데이터 등을 일정하게 나누어 버킷화하면 효과적으로 사용

```javascript
{
    sensor_id: 12345,
    start_date: ISODate("2019-01-31T10:00:00.000Z"),
    end_date: ISODate("2019-01-31T10:59:59.000Z"),
    measurements: [
       {
       timestamp: ISODate("2019-01-31T10:00:00.000Z"),
       temperature: 40
       },
       {
       timestamp: ISODate("2019-01-31T10:01:00.000Z"),
       temperature: 40
       },
       ...
       {
       timestamp: ISODate("2019-01-31T10:42:00.000Z"),
       temperature: 42
       }
    ],
   transaction_count: 42,
   sum_temperature: 2413
}
```

### 이상치 패턴
- 드물게 도큐먼트의 쿼리가 애플리케이션의 정상적인 패턴을 벗어날 때 사용
- flag를 사용해(사용자가 지정한 키) 해당 도큐먼트가 outlier 임을 나타내고, 애플리케이션에서 추가 검색을 하도록 처리할 수 있다

### 계산된 패턴
- 데이터가 자주 계산하거나 access pattern 이 읽기에 치중되었을 때 사용
- 특정 시간 별로 미리 계산(집계)를 해두어 cpu 리소스를 낭비하지 않도록 하는 패턴
  - 어떤 형태로 미리 집계할지에 대해서는 애플리케이션 개발자가 정하는 것이 좋다

### 서브셋 패턴
몽고DB는 working set을 RAM에 보관하는데, 이 데이터의 용량이 할당된 물리적 RAM을 초과하면 디스크 액서스가 시작되고 성능이 저하된다. 
이러한 현상은 애플리케이션에서 자주 사용하지 않는 대용량 도큐먼트로 인해 발생할 수 있는 데, 이를 방지하기 위해 서브셋 패턴을 사용한다.
- 자주 사용하는 데이터와 자주 사용하지 않는 데이터를 두 개의 개별 컬렉션으로 분할

> working set : 몽고DB가 가장 자주 사용하는 데이터 집합

### 확장된 참조 패턴
특정 기능을 위해 JOIN 작업이 다소 많이 필요한 경우에 고려해볼 수 있음
- JOIN으로 참조하는 대신 자주 액세스하는 필드만 복사해온다
- 데이터가 중복될 수 있다

### 근사 패턴
리소스가 많이 드는 계산이 필요하지만 정확도가 높지 않아도 되는 상황에 유용
- 카운팅을 하는 작은 컬렉션을 만들고, 특정 수치가 될때마다 원본 도큐먼트를 갱신하는 방식으로 사용 가능

### 트리 패턴
계층적인 데이터가 있을 때 적용
- `$graphLookUp` 과 같은 연산자를 사용할 수도 있음 => 쿼리에 소요되는 리소스가 많을 경우 트리패턴을 고려해볼 수 있음. 혹은 도큐먼트에서 `$graphLookUp` 사용 빈도가 높은 경우
- 다중조인을 피할 수 있지만 그래프에 대한 갱신을 관리해야 함

### 사전 할당 패턴
나중에 채워질 빈 구조를 사전 할당
- 과거의 MMAP 스토리지 엔진 사용시 많이 사용되던 패턴

### 도큐먼트 버전 관리 패턴
도큐먼트에 버전제어 기능이 필요할 때 적용
- 사용하기 적합한 경우
  1. 각 도큐먼트의 수정본이 너무 많지 않은 경우(각 도큐먼트마다 버전이 너무 많이 생성되지 않아야 함)
  2. 버전을 지정할 도큐먼트의 숫자가 너무 많지 않은 경우
  3. 수행되는 대부분의 쿼리는 도큐먼트의 최신 버전에서 수행

# 정규화 vs 비정규화
- 상대적으로 정규화는 쓰기가 빠르고, 비정규화는 읽기가 빠르다
- 정보 갱신이 잦으면 정규화하면 좋지만, 모든 읽기 속도를 희생하는 것과 트레이드 오프 해야함
- 내장 도큐먼트를 사용하기로 결정하고 도큐먼트를 갱신해야 한다면, 갱신을 재시도할 방법이 필요 => multi update 실패시 처리 로직 등
  - 멱등이 아닌 연산자의 경우 작업을 멱등한 단위로 쪼개야 함

## 정규화
몽고DB 집계 프레임워크는 소스 컬렉션에 일치하는 도큐먼트가 있는 결합된 컬렉션에 도큐먼트를 추가해 left outer join 을 수행하는 `$lookup` 단계와의 조인을 제공하는 것을 사용할 수 있다

## 비정규화
쿼리를 하나만(혹은 정규화에 비해 작게) 사용해 정보를 얻을 수 있지만, 더 많은 공간을 차지하고 동기화하기가 어려움

## 도큐먼트 내장 방식과 참조 방식의 비교
|내장방식이 좋은 경우|참조방식이 좋은 경우|
|--|--|
|작은 서브도큐먼트|큰 서브도큐먼트|
|주기적으로 변하지 않는 데이터|자주 변하는 데이터|
|결과적인 일관성이 허용될 때|즉각적인 일관성이 필요할 때|
|증가량이 적은 도큐먼트|증가량이 많은 도큐먼트|
|두 번째 쿼리를 수행하는 데 자주 필요한 데이터|결과에서 자주 제외되는 데이터|
|빠른 읽기|빠른쓰기|

## 카디널리티
컬렉션이 다른 컬렉션을 얼마나 참조하는 지 나타내는 개념

많고 적음의 관계를 결정하면 무엇을 내장하고 무엇을 참조할지 결정하는 데 도움이 된다. 일반적으로 `적음`관계는 내장, `많음`관계는 참조가 적합

# 데이터베이스와 컬렉션 구상
- 일반적으로 스키마가 유사한 도큐먼트는 같은 컬렉션에 보관
  - 몽고DB는 보통 서로 다른 컬렉션에 있는 데이터의 결합을 허용하지 않는다.
  - 따라서 함께 쿼리하거나 집계해야 하는 도큐먼트는 하나의 큰 컬렉션에 넣는 것이 좋다.
- 컬렉션에서는 락과 저장을 중요하게 고려해야 함
  - `--directoryperdb` 옵션으로 데이터베이스 디렉터리를 나눌 수 있음 => 서로 다른 볼륨에 마운트 가능
  - 데이터베이스 내 모든 항목이 비슷한 품질, 비슷한 접근 패턴, 비슷한 트래픽 수준을 갖는 것이 좋다

# 일관성 관리
- `readConcern` : 읽을 데이터의 일관성과 격리속성을 제어
  - `local, available, majority, linearizable, snapshot` 의 5개의 격리레벨이 있음
- `writeConcern` : 쓰기 작업을 위해 요청한 승인 여부 제어

# 스키마 관리
- `validator, collMod` : 기존 컬렉션에 유효성 검사 추가
- `createCollection()`과 함께 `validator` 사용하여 새로운 컬렉션에 유효성 검사 추가
  - `validationLevel` : 기존 도큐먼트 갱신 중에 유효성 검사 규칙을 얼마나 엄격하게 적용할지 결정
  - `validationAction` : 검증 실패한 도큐먼트를 오류 or 경고 발생할지 결정
