# 인덱싱 소개
- 컬렉션 스캔(collection scan) : 인덱스를 사용하지 않는 쿼리
  - full table scan 과 같이 서버가 쿼리 결과를 찾으려면 전체 내용을 살펴봐야 함
- 생성한 인덱스 목록 확인
  `db.collection.getIndexes()`

## explain : 실행계획을 확인할 수 있는 함수
- 파라미터를 넘겨서 모드를 설정할 수 있다

### queryPlanner
- 기본 모드
- 해당 쿼리를 위해 선택된 최적의 실행계획만 보여준다
- 가장 단순한 실행계획 결과를 보여준다
- 분석 가능한 정보
  - 쿼리가 의도했던 인덱스를 제대로 활용했는 지 확인
  - 쿼리가 정렬 작업을 인덱스를 활용해서 처리하는 지 확인
  - 쿼리의 프로젝션이 인덱스를 이용해서 처리되는 지 확인(커버링 인덱스 처리 여부)

### executionStatus
- `queryPlanner`의 모든 내용 + 선택된 최적 실행 계획을 실행하고 실행된 내용을 상세히 보여주는 모드
- 분석 가능한 정보
  - 인덱스의 선택도(Selectivity)가 좋은 지 확인
  - 실행 계획의 각 처리 단계에서 어떤 스테이지가 가장 느린 지 확인

### allPlansExecution
- `executionStatus`의 모든 내용 + 옵티마이저가 최적의 실행 계획을 선택하기 위해서 평가했던 나머지 후보 실행 계획들의 내용도 모두 포함해서 보여준다.
- 분석 가능한 정보
  - 옵티마이저가 어떤 실행 계획들을 검토했는 지 확인
  - 여러 실행 계획 중에서 왜 최적 실행 계획이 선택되었는 지 확인

## 인덱스 생성
- `createIndex` 명령어로 인덱스를 생성
- `db.currentOp()` 명령어로 인덱스 구축의 진행률을 체크할 수 있다
- 인덱싱된 필드는 쓰기 작업이 비교적 느림
> 몽고DB 인덱스는 전형적인 RDB 인덱스와 거의 동일하게 동작

### 간단한 성능 비교
- 약 350만건의 데이터를 넣고 컬렉션 스캔과 인덱스 스캔을 비교해보았다
- 결과는 편의를 위해 간략화 함
```javascript
// collection scan
{
    "executionStats" : {
        "nReturned": 1,
        "executionTimeMillis":1890,
        "totalKeysExamined":0,   // 인덱스 설정을 하지 않았기 때문에
        "totalDocsExamined":3513258,
        "executionStages" : {
            "stage": "COLLSCAN",
            "nReturend": 1,
            "executionTimeMillisEstimate" : 236,
			"works" : 3513260,
			"advanced" : 1,
			"needTime" : 3513258,
			"needYield" : 0,
			"saveState" : 27447,
			"restoreState" : 27447,
			"isEOF" : 1,
			"direction" : "forward",    
			"docsExamined" : 3513258
        }
    }
}

// index scan
{
    "executionStats" : {
        "nReturned": 1,
        "executionTimeMillis":9,
        "totalKeysExamined":1,
        "totalDocsExamined":1,
        "executionStages" : {
            "stage" : "FETCH",
            "nReturned" : 1,
            "executionTimeMillisEstimate" : 1,
            "works" : 2,
            "advanced" : 1,
            "needTime" : 0,
            "needYield" : 0,
            "saveState" : 0,
            "restoreState" : 0,
            "isEOF" : 1,
            "docsExamined" : 1,
            "alreadyHasObj" : 0,
            "inputStage" : {
                "stage" : "IXSCAN",
                "nReturned" : 1,
                "executionTimeMillisEstimate" : 1,
                "works" : 2,
                "advanced" : 1,
                "needTime" : 0,
                "needYield" : 0,
                "saveState" : 0,
                "restoreState" : 0,
                "isEOF" : 1,
                "keyPattern" : {
                    "username" : 1
                },
                "indexName" : "username_1",
                "isMultiKey" : false,
                "multiKeyPaths" : {
                    "username" : [ ]
                },
                "isUnique" : false,
                "isSparse" : false,
                "isPartial" : false,
                "indexVersion" : 2,
                "direction" : "forward",
                "indexBounds" : {
                    "username" : [
                        "[\"user101\", \"user101\"]"
                    ]
                },
                "keysExamined" : 1,
                "seeks" : 1,
                "dupsTested" : 0,
                "dupsDropped" : 0
            }
        }
    }
}
```
- `nRetunred` : 반환한 도큐먼트 개수
- `executionTimeMillis` : 실제 수행에 걸린 시간
- `totalKeysExamined` : 인덱스에서 읽은 인덱스 키의 개수
- `totalDocsExamined` : 스캔한 도큐먼트 개수
- `executionStages` : 각 스테이지에 대한 실행 계획
  - `stage` : 현재 스테이지 타입
  - `nRetunred` : 현재 스테이지의 처리 결과 상위 스테이지로 반환한 도큐먼트 개수
  - `executionTimeMillisEstimate` : 현재 스테이지(자식 스테이지를 포함)를 처리하는 데 걸린 시간(밀리초)
  - `works` : 현재 스테이지의 `work()`함수가 호출된 횟수
  - `advanced` : 현재 스테이지가 도큐먼트를 반환한 횟수(`ADVENCED`를 반환한 횟수)
  - `needTime` : 현재 스테이지가 도큐먼트를 반환하지 못한 횟수(`NEED_TIME`을 반환한 횟수)
  - `needYield` : 현재 스테이지가 처리되면서 `Yield`를 실행한 횟수
  - `isEOF` : 현재 스테이지가 `EOF`를 반환한 횟수(거의 항상 0 또는 1)
  - 

### WinningPlan Stage
- stage 는 각 단계를 나타냄
- 리프 노드로부터 연산되어 온다면 여러개의 중첩 `inputStage`로 이루어질 수 있다
> **stage operation 내용추가 필요 (REAL mongodb 818p 참조)**
- stage operation
  - `COLLSCAN` : collection scan
  - `IXSCAN` : index scan
  - `FETCH` : 도큐먼트 반환
  - `SHARD_MERGE` : 샤드에서 병합된 결과 반환
  - `SHARDING_FILTER` : 샤드에서 필터링
  - `SORT` : 인메모리 정렬 (인덱스를 이용하지 못함)
  - `SORT_KEY_GENERATOR` : 인덱스를 이용한 정렬

## 복합 인덱스
- 2개 이상의 필드로 구성된 인덱스
- 인덱스는 정렬된 상태로 저장되기 때문에 인덱스의 선두 컬럼이 정렬의 앞부분에 있으면 성능 향상에 도움이 된다

### 예제
복합인덱스 생성
```javascript
> db.users.createIndex({"age":1, "username":1})
```

복합인덱스를 이용한 쿼리 <br>
몽고DB는 index를 어느 방향으로든 쉽게 탐색하므로 정렬방향 상관없이 성능이 좋게 나온다
```javascript
// 인덱싱된 age 를 equals 연산으로 찾기 때문에 빠르게 쿼리 할 수 있다.
> db.users.find({"age":21}).sort({"username":-1})
```

인덱스를 이용한 범위쿼리
```javascript
// 범위 쿼리 => index scan
> db.users.find({"age": {$gte: 21, $lte: 30}})
```

정렬을 포함한 범위 쿼리 <br>
인덱스는 정렬된 순서로 사용자명을 반환하지 않기 때문에(age가 선두 컬럼이라서) 메모리에서 정렬해야해서 효율이 떨어진다. 결과가 32MB 이상이면 오류가 발생한다
```javascript
> db.users.find({"age": {$gte: 21, $lte: 30}}).sort({"username":1})
```
> 오류를 피하려면 limit 을 같이사용해 결과를 32MB 이하로 줄이면 된다

키를 역순으로 한 `{"username" : 1, "age" : 1}` 과 같은 인덱스도 사용가능하다. 모든 인덱스 항목을 탐색하지만 인메모리 정렬은 하지 않는다. 하지만 효율적이지 못하다.

## 몽고DB가 인덱스를 선택하는 방법
- 쿼리가 들어오면 몽고DB는 쿼리모양(query shape)을 확인 => 검색할 필드와 정렬 여부 등의 추가 정보와 관련있음
- 수행 방법
  - N 개의 쿼리 인덱스에 대해 쿼리 플랜을 만들고, 각각에 대해 병렬 스레드를 할당하여 쿼리를 실제 실행해보고, 가장 빨리 결과를 반환하는 플랜을 체택하는 데, 이와 같은 과정을 레이스라고 함
  - 플랜은 일정 기간(시범기간 : `trial period`) 동안 경쟁하며 시범기간동안 경쟁한 결과로 전체 승리 플랜(`Winning plan`) 을 산출한다.
  - 결정된 승리 플랜을 서버의 캐시로 저장하고 같은 쿼리 모양에 대해서는 캐시된 플랜을 사용한다
- 캐시된 플랜이 제거되는 경우
  - 인덱스 추가, 생성, 삭제 등 변경이 일어날 때
  - 명시적으로 삭제 : `db.collection.getPlanCache().clear()`
  - 몽고DB 서버 재시작
> 캐시된 쿼리 플랜을 확인하고 싶다면 `db.collection.getPlanCache().list()` => mongodb 버전이 4.4 이상이어야 가능. 4.4이전은 `db.collection.getPlanCache().listQueryShapes()` 사용

## 복합 인덱스 사용
인덱스의 선택성(selectivity) 고려해야 함
> index selectivity :  인덱스가 범위를 좁히는 데 얼마나 도움을 줄 수 있는 가에 대한 지표. 즉, 선택성이 높은 인덱스는 좀 더 유니크한 값에 가까우며 성능 향상에 도움을 줄 수 있다

- `executionStats`의 `totalKeysExamined`와 `nReturned`를 비교하면 쿼리와 일치하는 도큐먼트를 찾으려고 얼마나 많은 인덱스를 통과한지 확인할 수 있다. 
  - 두 수의 격차가 클 수록 인덱스의 선택성이 낮음을 알 수 있다. 
  > **선택성은 인덱스 성능 측정의 핵심지표이다**
- 쿼리 플랜은 힌트를 사용하여 원하는 인덱스를 사용하도록 유도할 수 있다. 하지만 신중히 사용해야 하며 운영환경에 사용하면 안된다.
  - 힌트를 줄 경우 rejectedPlans는 실행하지 않는다
- 복합 인덱스를 설계할 때는 인덱스를 사용할 공통 쿼리 패턴의 동등 필터, 다중값 필터, 정렬 구성 요소 처리 방법에 대해 알아야 한다.
- 인메모리 정렬(`SORT`) 시 인덱스 정렬(`SORT_KEY_GENERATOR`)보다 속도가 느림
  - 인메모리 정렬시에는 실행계획을 보면 메모리 사용량을 보여준다(`memUsage`)

### 복합인덱스 설계 시 고려 요소
- 동등 필터에 대한 키를 맨 앞에 표시
- 정렬에 사용되는 키는 다중값 필드 앞에 표시
- 다중값 필터에 대한 키는 마지막에 표시

### 키 방향 선택
- 복합 인덱스에서는 정렬 최적화를 위해 정렬 방향도 고려해야 한다
- `{"age":1, "username" : 1}`은 `{"age":1, "username" : -1}`과 같은 정렬에서는 인덱스 정렬을 이용할 수 없다
- 역방향 인덱스(inverse index)는 적용이 가능하기 때문에 `{"age":1, "username" : -1}`과 `{"age":-1, "username" : 1}`은 같은 인덱스로 정렬할 수 있다

### 커버드 쿼리 사용
- 인덱스가 쿼리가 요구하는 모든 값을 포함하면 쿼리가 `covered` 된다고 한다
- 항상 `covered query` 를 사용하는 것이 좋다

### 암시적 인덱스
인덱스 선두 컬럼만 사용해도 인덱스 적용을 받을 수 있다

## $ 연산자의 인덱스 사용법
### 비효율적인 연산자
- 일반적으로 부정 조건은 비효율적
- `$ne` 쿼리는 인덱스를 사용하긴 하지만 잘 활용하지 못함
  - `$ne`로 지정된 항목을 제외한 모든 인덱스 항목을 살펴봐야 하므로 기본적으로 전체 인덱스를 살펴봐야 함
- `$not`을 사용하는 쿼리 대부분 collection scan
- `$nin`은 항상 collection scan

### 범위
복합 인덱스 설계시 동등 필터에 대한 키를 앞 쪽에 두고 범위 필터를 뒤쪽에 둘 수록 쿼리 성능이 향상된다

### OR 쿼리
- 몽고DB는 기본적으로 쿼리당 하나의 인덱스만 사용이 가능하지만 `$or` 사용시 `$or`절 하나마다 인덱스를 사용할 수 있다
- `$or`는 두 쿼리의 결과를 모두 조사하고 중복되는 도큐먼트를 모두 제거하기 때문에 상당한 성능 하락이 있을 수 있다
- 가능하다면 `$in`을 사용하자
  - `$in` 쿼리는 정렬을 사용하지 않으면 도큐먼트의 순서를 제어할 수 없다
    ```javascript
    // 아래의 두 조건은 동일한 순서로 도큐먼트를 반환함
    {"x": {$in: [1, 2, 3]}}
    {"x": {$in: [3, 2, 1]}}
    ```
