# 인덱싱 소개
- 컬렉션 스캔(collection scan) : 인덱스를 사용하지 않는 쿼리
  - full table scan 과 같이 서버가 쿼리 결과를 찾으려면 전체 내용을 살펴봐야 함

## explain : 실행계획을 확인할 수 있는 함수
- 파라미터를 넘겨서 모드를 설정할 수 있다

### queryPlanner
- 기본 모드
- 해당 쿼리를 위해 선택된 최적의 실행계획만 보여준다
- 가장 단순한 실행계획 결과를 보여준다
- 분석 가능한 정보
  - 쿼리가 의도했던 인덱스를 제대로 활용했는 지 확인
  - 쿼리가 정렬 작업을 인덱스를 활용해서 처리하는 지 확인
  - 쿼리의 프로젝션이 인덱스를 이용해서 처리되는 지 확인(커버링 인덱스 처리 여부)

### executionStatus
- `queryPlanner`의 모든 내용 + 선택된 최적 실행 계획을 실행하고 실행된 내용을 상세히 보여주는 모드
- 분석 가능한 정보
  - 인덱스의 선택도(Selectivity)가 좋은 지 확인
  - 실행 계획의 각 처리 단계에서 어떤 스테이지가 가장 느린 지 확인

### allPlansExecution
- `executionStatus`의 모든 내용 + 옵티마이저가 최적의 실행 계획을 선택하기 위해서 평가했던 나머지 후보 실행 계획들의 내용도 모두 포함해서 보여준다.
- 분석 가능한 정보
  - 옵티마이저가 어떤 실행 계획들을 검토했는 지 확인
  - 여러 실행 계획 중에서 왜 최적 실행 계획이 선택되었는 지 확인

## 인덱스 생성
- `createIndex` 명령어로 인덱스를 생성
- `db.currentOp()` 명령어로 인덱스 구축의 진행률을 체크할 수 있다
- 인덱싱된 필드는 쓰기 작업이 비교적 느림
> 몽고DB 인덱스는 전형적인 RDB 인덱스와 거의 동일하게 동작

### 간단한 성능 비교
- 약 350만건의 데이터를 넣고 컬렉션 스캔과 인덱스 스캔을 비교해보았다
- 결과는 편의를 위해 간략화 함
```javascript
// collection scan
{
    "executionStats" : {
        "nReturned": 1,
        "executionTimeMillis":1890,
        "totalKeysExamined":0,   // 인덱스 설정을 하지 않았기 때문에
        "totalDocsExamined":3513258,
        "executionStages" : {
            "stage": "COLLSCAN",
            "nReturend": 1,
            "executionTimeMillisEstimate" : 236,
			"works" : 3513260,
			"advanced" : 1,
			"needTime" : 3513258,
			"needYield" : 0,
			"saveState" : 27447,
			"restoreState" : 27447,
			"isEOF" : 1,
			"direction" : "forward",    
			"docsExamined" : 3513258
        }
    }
}

// index scan
{
    "executionStats" : {
        "nReturned": 1,
        "executionTimeMillis":9,
        "totalKeysExamined":1,
        "totalDocsExamined":1,
        "executionStages" : {
            "stage" : "FETCH",
            "nReturned" : 1,
            "executionTimeMillisEstimate" : 1,
            "works" : 2,
            "advanced" : 1,
            "needTime" : 0,
            "needYield" : 0,
            "saveState" : 0,
            "restoreState" : 0,
            "isEOF" : 1,
            "docsExamined" : 1,
            "alreadyHasObj" : 0,
            "inputStage" : {
                "stage" : "IXSCAN",
                "nReturned" : 1,
                "executionTimeMillisEstimate" : 1,
                "works" : 2,
                "advanced" : 1,
                "needTime" : 0,
                "needYield" : 0,
                "saveState" : 0,
                "restoreState" : 0,
                "isEOF" : 1,
                "keyPattern" : {
                    "username" : 1
                },
                "indexName" : "username_1",
                "isMultiKey" : false,
                "multiKeyPaths" : {
                    "username" : [ ]
                },
                "isUnique" : false,
                "isSparse" : false,
                "isPartial" : false,
                "indexVersion" : 2,
                "direction" : "forward",
                "indexBounds" : {
                    "username" : [
                        "[\"user101\", \"user101\"]"
                    ]
                },
                "keysExamined" : 1,
                "seeks" : 1,
                "dupsTested" : 0,
                "dupsDropped" : 0
            }
        }
    }
}
```
- `nRetunred` : 반환한 도큐먼트 개수
- `executionTimeMillis` : 실제 수행에 걸린 시간
- `totalKeysExamined` : 인덱스에서 읽은 인덱스 키의 개수
- `totalDocsExamined` : 스캔한 도큐먼트 개수
- `executionStages` : 각 스테이지에 대한 실행 계획
  - `stage` : 현재 스테이지 타입
  - `nRetunred` : 현재 스테이지의 처리 결과 상위 스테이지로 반환한 도큐먼트 개수
  - `executionTimeMillisEstimate` : 현재 스테이지(자식 스테이지를 포함)를 처리하는 데 걸린 시간(밀리초)
  - `works` : 현재 스테이지의 `work()`함수가 호출된 횟수
  - `advanced` : 현재 스테이지가 도큐먼트를 반환한 횟수(`ADVENCED`를 반환한 횟수)
  - `needTime` : 현재 스테이지가 도큐먼트를 반환하지 못한 횟수(`NEED_TIME`을 반환한 횟수)
  - `needYield` : 현재 스테이지가 처리되면서 `Yield`를 실행한 횟수
  - `isEOF` : 현재 스테이지가 `EOF`를 반환한 횟수(거의 항상 0 또는 1)
  - 

### WinningPlan Stage
- stage 는 각 단계를 나타냄
- 리프 노드로부터 연산되어 온다면 여러개의 중첩 `inputStage`로 이루어질 수 있다
> **stage operation 내용추가 필요 (REAL mongodb 818p 참조)**
- stage operation
  - `COLLSCAN` : collection scan
  - `IXSCAN` : index scan
  - `FETCH` : 도큐먼트 반환
  - `SHARD_MERGE` : 샤드에서 병합된 결과 반환
  - `SHARDING_FILTER` : 샤드에서 필터링

## 복합 인덱스
- 2개 이상의 필드로 구성된 인덱스
- 인덱스는 정렬된 상태로 저장되기 때문에 인덱스의 선두 컬럼이 정렬의 앞부분에 있으면 성능 향상에 도움이 된다

### 예제
복합인덱스 생성
```javascript
> db.users.createIndex({"age":1, "username":1})
```

복합인덱스를 이용한 쿼리 <br>
몽고DB는 index를 어느 방향으로든 쉽게 탐색하므로 정렬방향 상관없이 성능이 좋게 나온다
```javascript
// 인덱싱된 age 를 equals 연산으로 찾기 때문에 빠르게 쿼리 할 수 있다.
> db.users.find({"age":21}).sort({"username":-1})
```

인덱스를 이용한 범위쿼리
```javascript
// 범위 쿼리 => index scan
> db.users.find({"age": {$gte: 21, $lte: 30}})
```

정렬을 포함한 범위 쿼리 <br>
인덱스는 정렬된 순서로 사용자명을 반환하지 않기 때문에(age가 선두 컬럼이라서) 메모리에서 정렬해야해서 효율이 떨어진다. 결과가 32MB 이상이면 오류가 발생한다
```javascript
> db.users.find({"age": {$gte: 21, $lte: 30}}).sort({"username":1})
```
> 오류를 피하려면 limit 을 같이사용해 결과를 32MB 이하로 줄이면 된다

키를 역순으로 한 `{"username" : 1, "age" : 1}` 과 같은 인덱스도 사용가능하다. 모든 인덱스 항목을 탐색하지만 인메모리 정렬은 하지 않는다. 하지만 효율적이지 못하다.

## 몽고DB가 인덱스를 선택하는 방법
- 쿼리가 들어오면 몽고DB는 쿼리모양(query shape)을 확인 => 검색할 필드와 정렬 여부 등의 추가 정보와 관련있음
- 수행 방법
  - N 개의 쿼리 인덱스에 대해 쿼리 플랜을 만들고, 각각에 대해 병렬 스레드를 할당하여 쿼리를 실제 실행해보고, 가장 빨리 결과를 반환하는 플랜을 체택하는 데, 이와 같은 과정을 레이스라고 함
  - 플랜은 일정 기간(시범기간 : `trial period`) 동안 경쟁하며 시범기간동안 경쟁한 결과로 전체 승리 플랜(`Winning plan`) 을 산출한다.
  - 결정된 승리 플랜을 서버의 캐시로 저장하고 같은 쿼리 모양에 대해서는 캐시된 플랜을 사용한다
- 캐시된 플랜이 제거되는 경우
  - 인덱스 추가, 생성, 삭제 등 변경이 일어날 때
  - 명시적으로 삭제 : `db.collection.getPlanCache().clear()`
  - 몽고DB 서버 재시작
> 캐시된 쿼리 플랜을 확인하고 싶다면 `db.collection.getPlanCache().list()` => mongodb 버전이 4.4 이상이어야 가능. 4.4이전은 `db.collection.getPlanCache().listQueryShapes()` 사용
