# 인덱싱 소개
- 컬렉션 스캔(collection scan) : 인덱스를 사용하지 않는 쿼리
  - full table scan 과 같이 서버가 쿼리 결과를 찾으려면 전체 내용을 살펴봐야 함

## explain : 실행계획을 확인할 수 있는 함수
- 파라미터를 넘겨서 모드를 설정할 수 있다

### queryPlanner
- 기본 모드
- 해당 쿼리를 위해 선택된 최적의 실행계획만 보여준다
- 가장 단순한 실행계획 결과를 보여준다
- 분석 가능한 정보
  - 쿼리가 의도했던 인덱스를 제대로 활용했는 지 확인
  - 쿼리가 정렬 작업을 인덱스를 활용해서 처리하는 지 확인
  - 쿼리의 프로젝션이 인덱스를 이용해서 처리되는 지 확인(커버링 인덱스 처리 여부)

### executionStatus
- `queryPlanner`의 모든 내용 + 선택된 최적 실행 계획을 실행하고 실행된 내용을 상세히 보여주는 모드
- 분석 가능한 정보
  - 인덱스의 선택도(Selectivity)가 좋은 지 확인
  - 실행 계획의 각 처리 단계에서 어떤 스테이지가 가장 느린 지 확인

### allPlansExecution
- `executionStatus`의 모든 내용 + 옵티마이저가 최적의 실행 계획을 선택하기 위해서 평가했던 나머지 후보 실행 계획들의 내용도 모두 포함해서 보여준다.
- 분석 가능한 정보
  - 옵티마이저가 어떤 실행 계획들을 검토했는 지 확인
  - 여러 실행 계획 중에서 왜 최적 실행 계획이 선택되었는 지 확인

### WinningPlan Stage
- stage 는 각 단계를 나타냄
- 리프 노드로부터 연산되어 온다면 여러개의 중첩 `inputStage`로 이루어질 수 있다
- stage operation
  - `COLLSCAN` : collection scan
  - `IXSCAN` : index scan
  - `FETCH` : 도큐먼트 반환
  - `SHARD_MERGE` : 샤드에서 병합된 결과 반환
  - `SHARDING_FILTER` : 샤드에서 필터링

## 인덱스 생성
- `createIndex` 명령어로 인덱스를 생성
- `db.currentOp()` 명령어로 인덱스 구축의 진행률을 체크할 수 있다
- 인덱싱된 필드는 쓰기 작업이 비교적 느림
> 몽고DB 인덱스는 전형적인 RDB 인덱스와 거의 동일하게 동작

### 간단한 성능 비교
- 약 350만건의 데이터를 넣고 컬렉션 스캔과 인덱스 스캔을 비교해보았다
- 결과는 편의를 위해 간략화 함
```javascript
// collection scan
{
    "executionStats" : {
            "nReturned": 1,
            "executionTimeMillis":1890,
            "totalDocsExamined":3513258
    }
}

// index scan
{
    "executionStats" : {
            "nReturned": 1,
            "executionTimeMillis":9,
            "totalDocsExamined":1
    }
}
```
- `nRetunred` : 반환한 도큐먼트 개수
- `executionTimeMillis` : 실제 수행에 걸린 시간
- `totalDocsExamined` : 스캔한 도큐먼트 개수

## 복합 인덱스
- 2개 이상의 필드로 구성된 인덱스
- 인덱스는 정렬된 상태로 저장되기 때문에 인덱스의 선두 컬럼이 정렬의 앞부분에 있으면 성능 향상에 도움이 된다

### 예제
복합인덱스 생성
```javascript
> db.users.createIndex({"age":1, "username":1})
```

복합인덱스를 이용한 쿼리 <br>
몽고DB는 index를 어느 방향으로든 쉽게 탐색하므로 정렬방향 상관없이 성능이 좋게 나온다
```javascript
// 인덱싱된 age 를 equals 연산으로 찾기 때문에 빠르게 쿼리 할 수 있다.
> db.users.find({"age":21}).sort({"username":-1})
```

인덱스를 이용한 범위쿼리
```javascript
// 범위 쿼리 => index scan
> db.users.find({"age": {$gte: 21, $lte: 30}})
```

정렬을 포함한 범위 쿼리 <br>
인덱스는 정렬된 순서로 사용자명을 반환하지 않기 때문에(age가 선두 컬럼이라서) 메모리에서 정렬해야해서 효율이 떨어진다. 결과가 32MB 이상이면 오류가 발생한다
```javascript
> db.users.find({"age": {$gte: 21, $lte: 30}}).sort({"username":1})
```
> 오류를 피하려면 limit 을 같이사용해 결과를 32MB 이하로 줄이면 된다

키를 역순으로 한 `{"username" : 1, "age" : 1}` 과 같은 인덱스도 사용가능하다. 모든 인덱스 항목을 탐색하지만 인메모리 정렬은 하지 않는다. 하지만 효율적이지 못하다.