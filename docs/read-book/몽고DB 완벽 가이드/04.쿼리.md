# find
- 쿼리에 사용
  - 쿼리는 도큐먼트의 서브셋을 반환(빈 컨렉션부터 컬렉션 전체까지)
- 빈 쿼리 도큐먼트({})는 컬렉션 내 모든 것과 일치
  - 매개변수에 쿼리 도큐먼트가 없으면 빈 쿼리 도큐먼트로 인식
```javascript
> db.c.find()
```
- 쿼리 도큐먼트에 여러 개의 키/값 쌍을 추가하면 `조건1 and 조건2 and ... 조건N`과 같은 형태로 조회한다
```javascript
// username = joe and age = 27
> db.users.find({"username":"joe", "age":27})
```

## 반환받을 키 지정
- 두 번째 매개변수에 원하는 키를 지정
- value 에 `1 = 포함` , `0 = 미포함`
```javascript
// username 은 결과에 포함, _id 는 결과에 포함하지 않음
> db.users.find({}, {"username":1, "_id":0})
```

## 제약 사항
데이터베이스에서 쿼리 도큐먼트 값은 반드시 상수여야 함

# 쿼리 조건
완전 일치, 범위, OR, 부정 조건 등으로 쿼리가 가능함

### 쿼리 조건절
|쿼리 기호|수학 기호|
|--|--|
|$lt|<|
|$lte|<=|
|$gt|>|
|$gte|>=|
|$ne|!=|

- 날짜는 밀리초 단위로 저장되므로 일치 조건은 유용성이 떨어짐
- `$ne`는 모든 데이터형에 사용 가능

### OR 쿼리
`$in` : 하나의 키를 다양한 값과 비교
```javascript
> db.raffle.find({"ticket_no" : {$in: [725, 542, 390]}})
// 서로 다른 데이터형도 사용 가능
> db.raffle.find({"user_id" : {$in: ["test", 1234]}})
```
`$nin` : not in 의 의미
```javascript
// 725, 542, 390 이 포함되지 않은 도큐먼트 반환
> db.raffle.find({"ticket_no" : {$nin: [725, 542, 390]}})
```
`$or` : 여러 키를 주어진 값과 비교
```javascript
// ticket_no 가 725 이거나 winner 가 true 인 도큐먼트 반환
> db.raffle.find({$or : [{"ticket_no" : 725}, {"winner": true}]})
```

> 일반적인 AND 쿼리에서는 최소한의 인수로 최적의 결과(범위를 좁힌 결과)를 추려내야 하고, OR 는 첫 번째 인수가 일치하는 도큐먼트가 많을 수록 효율적이다 => short-circuit(단축평가) 생각해보면 됨

> 옵티마이저는 `$or` 보다 `$in`을 더 효율적으로 다룬다

### $not
메타 조건절(metaconditional)이며 어떤 조건에도 적용 가능
```javascript
// $mod => 1번째 파라미터로 나눈 결과가 2번째 파라미터인 값을 찾음
// not 연산으로 결국에는 5로 mod 연산한 결과가 1인 값을 제외한 도큐먼트를 찾음
> db.users.find({"id_num": {$not: {$mod: [5, 1]}}})
```
정규 표현식과 함께 자주 사용

# Type-Specific 쿼리
일부 데이터형은 쿼리 시 형에 특정하게 작동

## null
- null은 스스로와 일치하는 것을 찾음
  - 값이 null 이거나, 키 자체가 없는 것
- 값이 null인 키만 찾고 싶으면 키가 null인 값을 쿼리하고 `$exists` 조건절을 사용해 null 존재 여부 확인
```javascript
> db.c.find({"z": {$eq: null, $exists: true}})
```

## 정규표현식
- `$regex`는 정규식 기능을 제공
- 정규표현식 플래그를 optional하게 사용가능
- 몽고DB는 정규 표현식 일치에 펄 호환 정규 표현식(PCRE) 라이브러리 사용

## 배열에 쿼리하기
배열 요소 쿼리는 스칼라 쿼리와 같은 방식으로 동작하도록 설계됨

### $all
2개 이상의 배열 요소가 일치하는 배열을 찾음
```javascript
db.food.insertOne({"_id" : 1, "fruit": ["apple", "banana", "peach"]})
db.food.insertOne({"_id" : 2, "fruit": ["apple", "kumquat", "orange"]})
db.food.insertOne({"_id" : 3, "fruit": ["cherry", "banana", "apple"]})

> db.food.find({"fruit": {$all: ["apple", "banana"]}})
// 결과
// {"_id" : 1, "fruit": ["apple", "banana", "peach"]}
// {"_id" : 3, "fruit": ["cherry", "banana", "apple"]}

// 일치하는 것 찾기
> db.food.find({"fruit": ["apple", "banana", "peach"]})
// 결과
// {"_id" : 1, "fruit": ["apple", "banana", "peach"]}

// 배열 내 특정 요소 쿼리
> db.food.find({"fruit.2": "peach"})
// 결과
// {"_id" : 1, "fruit": ["apple", "banana", "peach"]}
```

### $size
- 특정 크기의 배열을 쿼리
- 다른 조건절과 결합할 수 없음 (`$gt` 등과 결합할 수 없기 때문에 범위 검색 불가)
  - 배열 크기로 범위 검색이 필요하면 size 를 나타내는 키를 추가하여 `$inc`와 조합하여 사용하자 => 값의 증가는 매우 빠르게 이뤄지므로 성능 이슈는 거의 없음
    - `$addToSet`과 같이 사용 불가

### $slice
find 에서 사용하여 배열 요소의 부분집합을 받을 수 있음
```javascript
// 최신 comments 10개 반환받음
> db.blog.posts.findOne(criteria, {"comments": {$slice: 10}})

// old comments 10개 반환받음
> db.blog.posts.findOne(criteria, {"comments": {$slice: -10}})

// offset, limit 지정 => offset : 23, limit : 10 지정
> db.blog.posts.findOne(criteria, {"comments": {$slice: [23, 10]}})
```

### 일치하는 배열 요소 반환
$ 연산자 사용
```javascript
// comments.name 이 bob 인 comments 중 1번째 comments 만 반환
> db.blog.posts.find({"comments.name": "bob"}, {"comments.$" : 1})
```

### 배열 및 범위 쿼리의 상호작용
배열에 대해 일반적인 쿼리를 적용하면 각각의 요소에 대해 조건을 적용하기 때문에, 모든 조건을 적용 시키기 위해서는 두가지 방법이 있다
1. `$elemMatch` 사용 : 배열이 아닌 필드에는 조건을 적용하지 않음
```javascript
// 각 요소가 10 ~ 20 이어야 됨
> db.test.find({"x" : {$elemMatch: {$gt: 10, $lt: 20}}})
```
> `$elemMatch` 가 배열인 키에만 필터가 적용이 되는데, 일반적으로는 데이터 타입을 배열인 것과 아닌 것을 하나의 키에 섞어 쓰지는 않지만 주의하야여 한다

2. 쿼리하는 필드에 인덱스가 있다면 min, max 함수를 사용해 범위 함수를 적용한다
```javascript
> db.test.find({"x": {$gt: 10, $lt:20}}).min({"x":10}).max({"x":20})
```
> 일반적으로 배열을 포함하는 도큐먼트에 범위 쿼리를 할 때 min, max 함수를 사용하면 좋다. 배열에 대한 `$gt/$lt` 쿼리의 index bound 는 비효율적이다. 어떤 값이든 허용하므로 범위 내 값 뿐 아니라 모든 인덱스 항목ㅇㄹ 검색한다.