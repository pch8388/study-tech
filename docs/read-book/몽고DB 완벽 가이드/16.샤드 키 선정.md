# 용도 평가
- 샤드 키 : 컬렉션을 샤딩할 때는 데이터 분할에 사용할 한두 개의 필드를 선택
  - MongoDB 4.4 를 기준으로 이전버전은 컬렉션에 샤딩된 샤드 키 변경이 불가하고, 4.4 부터의 버전에서는 변경이 가능 [참고](https://docs.mongodb.com/manual/core/sharding-change-a-shard-key/)

## 고려할 점
- 샤드를 얼마나 많이 늘릴 것인가
  - 샤딩된 클러스터가 많을 수록 모든 쿼리에 샤드키가 포함되는 것이 유리하다 => 바꿔말하면 클러스터 개수가 많을 수록 쿼리에 샤드키가 포함되지 않으면 모든 클러스터를 순회하기 때문에 성능이 저하된다
- 읽기 혹은 쓰기 응답 대기 시간을 줄이려고 샤딩하는가
  - 응답 대기 시간은 거리에 따른 요인이나 장비의 성능에 영향을 많이 받는다
- 읽기 혹은 쓰기 처리량을 늘리려고 샤딩하는가
  - 클러스터에 동시 요청을 통해 처리량을 늘릴 수 있다
- 시스템 리소스를 늘리려고 샤딩하는가
  - 작업 셋의 크기를 가능한 작게 유지

## 샤드 키 특징 평가
- 샤드 키가 필요한 타겟 쿼리를 제공하는가
- 샤드 키가 시스템의 처리량이나 응답 대기 시간을 의도한 대로 변경하는가
- 작은 작업 셋이 필요하면 샤드 키가 그것을 제공하는가

# 샤딩 구상
## 오름차순 샤드 키
- 시간에 따라 꾸준히 증가하는 것을 키로 선정 (date, ObjectId ...)
- 새 도큐먼트를 생성하면 `$maxKey`를 포함하는 최대청크에 삽입이 됨
  - 최대청크는 계속 커져서 여러개의 청크로 분할
- 청크를 균형잡힌 상태로 유지하기 힘듬
  - 지속적으로 청크를 다른 샤드로 이동해야 함
  - 4.2 이상버전부터는 청크 최적화가 추가되어 새 청크가 단 하나의 샤드에 생성되는 상황을 방지한다

## 무작위 분산 샤드 키
- 데이터 셋에서 고유하지 않은 키는 모두 가능
- 각 샤드가 거의 비슷한 비율로 커짐
- 몽고DB가 메모리 크기를 넘어서는 데이터를 임의로 접근하는 데 효율적이지 않다는 단점이 있음

## 위치 기반 샤드 키
- 반드시 물리적 위치가 아닌 데이터를 그룹화하는 추상적인 방법 => 태깅을 해서 그룹핑하는 것과 비슷함
- 유사성을 갖는 도큐먼트가 해당 필드 기반의 범위에 포함되는 키

# 샤드 키 전략
## 해시 샤드 키
- 데이터를 가능한 한 빠르게 로드하는 방법
- 단점 : 범위 쿼리를 할 수 없음

> unique 옵션, 배열 필드 사용 불가, 부동소수점 값은 해싱전에 정수로 치환됨

### 생성
1. 해시 인덱스`hashed index` 생성
  ```javascript 
  db.users.createIndex({"username":"hashed"})
  ```
2. 컬렉션 샤딩
  ```javascript 
  sh.shardCollection("app.users", {"username":"hashed"})
  ```

## 파이어 호스 전략
- 특정 서버에 더 많은 부하를 부담하도록 하는 전략
- 샤드를 영역화
- 단점 : 확장을 위해 다소 변경이 필요

# 샤드 키 규칙 및 지침
## 샤드 키 한계
- 샤드 키에 배열 사용 불가능

## 샤드 키 카디널리티
- 샤드 키는 고르게 입력될 값으로 선택해야 함