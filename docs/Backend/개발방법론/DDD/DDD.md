# 도메인 주도 개발
- 도메인 : 소프트웨어로 해결하고자 하는 문제 영역. 즉, 업무를 영역짓는 것
- 도메인 모델 : 도메인을 소프트웨어로 표현하기 위해 모델링
  - 소프트웨어 개발자가 해당 도메인에 대해 처음부터 완벽하게 이해하고 구현하기 힘듬
  - 순수하게 도메인에 대해 모델링 하는 개념적인 도메인 모델을 실제 구현에 모두 반영할 수 없음
  - 기술과의 융합이나 구현상의 이점등을 고려하여 개념모델에 가깝게 구현모델을 가져가야 함

## 도메인 모델 패턴
- 일반적인 애플리케이션은 4계층의 아키텍처로 구성
  1. Presentation layer : 클라이언트와의 인터렉션
  2. Application layer : 클라이언트 요청 기능 실행, 도메인 모델을 조합하여 사용, 외부 라이브러리 등의 도메인 외적인 기능들을 이 계층에서 사용함
  3. Domain layer : 도메인 기능을 실행할 계층
  4. Infrastructure : 외부 시스템과의 연동, DB 나 메시징 시스템 등등
- 각 계층은 하위 계층으로만 의존해야 함(상위 계층일수록 클라이언트와 가까움)
> 여기서 클라이언트라 함은 꼭 사용자만을 이야기하는 것이 아니라, http 를 포함한 모든 외부 요청을 말함
- 히자만, 구현을 하다보면 하위계층에 대한 의존성이 생기기 쉬움.
  - 예를 들어, 스프링으로 개발을 하다보면 service 계층에서 persistence 계층의 기술인 특정 데이터베이스 기술에 의존하는 경우가 많음(사실 영속성을 관계형 데이터베이스로 가져간다라고 규정하는 것 자체가 의존하는 것이다)
  - DIP (Dependency Inversion Principle) : 저수준 모듈이 아닌 고수준 모듈에 의존하도록 함으로써 이를 해결
  - service -> repository(interface) 를 의존시키고, 구체화된 기술은 repository interface 를 구현하도록 하여 해결

## 도메인 모델링
1. 요구사항 정리
  - 요구사항을 원하는 형태로 정리
  - 문장이나 순서도, 워크플로우 등을 이용
2. 요구사항에 따른 모델을 정의
  - 추상적으로 이름만 정할수도 있고, 좀 더 구체화 할 수도 있음
  
### Entity
- 엔티티는 식별자를 갖는다는 점에서 value 와 차이가 있음

### Value
- 엔티티가 가질 수 있는 값의 의미를 좀 더 잘 드러내고자 할 때 사용가능 (도메인 개념을 나타낼 수 있음)
- 불변 객체로 사용해야 함
- 밸류 타입을 위한 기능 추가 가능(ex. Money 객체라면 돈에 관련된 계산 로직을 넣을 수 있음)

### 도메인 용어
- 도메인 용어는 통일되고 의미가 명확해야 함

### 도메인 영역의 주요구성 요소
- 엔티티 : 고유식별자, 라이프사이클을 가짐, 도메인 고유의 개념을 표현
- 밸류 : 도메인 객체의 속성 표현
- 애그리거트 : 엔티티 + 밸류를 개념적으로 하나로 묶음
- 리포지토리 : 도메인 모델의 영속성 처리
- 도메인 서비스 : 도메인 로직이 여러 도메인을 사용해야 할 때 사용

## 애그리거트
- 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들기 위해 상위 수준에서 모델을 바라볼 수 있도록 하는 방법
- 관련된 객체를 하나의 군집으로 묶음으로써 도메인의 복잡도 하락
- 애그리거트안의 대부분의 객체는 생성과 소멸을 함께 한다
  - 이러한 기준으로 애그리거트 경계를 나누면 좀 더 쉽게 설계할 수 있음
- 애그리거트는 대부분 하나의 엔티티를 가짐

### 애그리거트 루트
- 애그리거트에 속한 객체를 일관성 있는 상태로 유지하도록 관리하는 객체
- 직.간접적으로 애그리거트의 객체들이 속함
- 애그리거트 루트를 통해서만 도메인 로직 구현해야 함
  - 밸류 타입을 불변하게 만들고, 외부에서 변경할 수 없게 캡슐화하여 애그리거트 루트에서 새로 생성하여 바꾸도록 구현
- 애그리거트 루트를 제외한 객체들을 protected 나 default 로 설정하는 것도 고려해야 함

### 애그리거트 트랜잭션
- 한 트랜잭션에서는 하나의 애그리거트만 수정해야 함 => 충돌 가능성 방지
- 응용 계층에서 두 애그리거트를 수정하도록 구현

### 리포지토리 
- 리포지토리 기술에 따라 애그리거트 구현에 영향이 생김
  - ex) JPA : Value 타입의 도메인 모델에 대해 @Entity 를 사용해야 하는 경우가 있음(table 에 저장)

### 애그리거트 참조
- JPA 를 사용해서 다른 애그리거트를 필드참조로 연관관계를 맺으면 편리하지만 단점도 따름
  1. 편리한 탐색 오용 => 다른 애그리거트를 편리하게 수정하려는 욕구가 생김
  2. 성능 이슈 => lazy 로딩으로 인해 n + 1 등의 문제
  3. 확장 어려움 => 애그리거트끼리 종속성이 생김
- id 를 이용한 참조를 통해 위의 단점을 해결 => lazy 로딩의 효과가 있음
  - n + 1 문제가 발생할 수 있는데 두가지 해결책
    1. 조회전용쿼리 생성
    2. CQRS 패턴 적용

## 리포지토리와 모델구현(with JPA)
- 애그리거트 루트는 @Entity
- 한 테이블에 엔티티와 밸류가 있으면
  - 밸류는 @Embeddable (밸류타입 정의 클래스)
  - 밸류타입 프로퍼티는 @Embedded (밸류타입 사용하는 필드)
  - 밸류타입이 또다른 밸류타입을 가질 수 있음
- get / set 보다는 기능에 맞는 이름을 지어야 함
  - 엔티티의 필드를 외부에서 마구 수정할 수 없게 set을 아예 만들지 않는 것이 좋음
  - @Access 로 필드 / 메서드 접근 방식에 대해 제어(JPA 가 어떤것으로 접근할지)
    - 붙이지 않으면 @Id 혹은 @EmbeddedId 를 단 위치에 따라 결정
- 컬렉션 형태의 밸류타입
  1. 별도 테이블에 매핑
    - @ElemnetCollection
    - @CollectionTable(...)
    - @OrderColumn
  2. 한개 컬럼 매핑
    - AttributeConverter 를 구현하여 값을 변환
- ID 를 식별자 의미 부각하기 위해 밸류 타입으로 구현 => @EmbeddedId
  - JPA 에서 식별자는 Serializable 타입이어야 함
- 밸류를 @Entity 사용해서 저장해야 하는 경우도 있음
  - Embeddable 은 상속구조 지원하지 않음
  - 상속 : @Inheritance
  - 밸류는 별도 라이프사이클을 가지지 않으므로 애그리거트 루트와 연관관계를 맺을 때, Casecade 와 orphanRemoval 을 통해 라이프사이클을 공유 시키자
  - 밸류를 엔티티로 만들어 저장할 경우 밸류를 바꿀 때, 쿼리가 비효율 적일 수 있음
    - 컬렉션으로 들어간 밸류를 삭제할 경우 list 를 모두 삭제하려면 select 쿼리 1번과 delete 쿼리를 list 사이즈만큼 해야함

### 애그리거트 로딩
- 개념적으로 애그리거트는 하나여야 함
- 즉시로딩을 하면 성능상 이슈 발생가능성(불필요 자원 호출)
  - 즉시로딩은 @Entity, @Embeddable 에 대해 다르게 동작
- 애그리거트의 특성에 따라 지연, 즉시 로딩 전략을 다르게 세워야 함

## 리포지토리 조회(with JPA)
- 조회 기능은 최적화 및 유연한 조건조회를 위해 쿼리를 직접 생성하거나 JPQL 같은 기술 도입을 고려
  - 기술에 의존성이 생길 수 있음 => 리포지토리가 변경될 일은 극히 드물기 때문에 어느정도는 의존을 감수한다
- 조회 전용기능을 만든다면 @Subselect, 네이티브쿼리, 동적인스턴스 생성(김영한님의 JPA 강의중 DTO 조회부분을 참고)을 고려

## 응용서비스와 표현영역
### 응용계층
- 응용계층은 표현계층이 어디로부터 요청을 받는지와 같은 정보를 모르도록 분리되어야 함
- 응용계층의 로직이 복잡하다면 도메인 로직을 응용계층에서 구현하는 것이 아닌지 의심해야 함
- 역할 : 도메인 객체간 실행 흐름 제어, 트랜잭션 처리
- 표현 영역과 도메인 영역을 연결하는 매개체의 역할(facade)
- 응용 서비스 클래스를 분리하는 기준
  1. 도메인별
    - 장점 : 동일 로직을 위한 코드 중복제거가 쉬움
    - 단점 : 클래스가 비대해 질 수 있음
  2. 기능별
    - 장점 : 코드품질을 일정수준으로 유지하기 쉬움
    - 단점 : 클래스 개수가 많아질 수 있음
    - 응용서비스를 역할별로 분리한다
      => 일반적인 MVC 구조일때 Controller 도 분리해야하는지??
      => 분리하지 않으면 의존성이 많아지고, 분리하면 클래스가 많아진다
- 표현 계층에 의존하지 않게 주의
- 이벤트를 발행하여 도메인 간이나 외부 서비스와의 의존도를 낮출 수 있음
- 조회를 위한 응용 서비스가 조회전용 기능만 존재한다면 생략 가능

### 표현계층
- 책임
  1. 사용자가 시스템을 사용할 수 있는 흐름을 제공하고 제어
  2. 요청에 따라 응용서비스에 전달하고 결과를 받아 사용자에게 맞게 반환
  3. 세션관리

### 유효성 검증
- 원칙적으로 응용계층에서 함
- 표현 계층에서 사용자가 입력한 값에 대해 검증하고 결과를 반환하면 사용자 편의성 향상에 도움을 줄 수 있음 => 응용계층에서의 검증은 값 하나하나에 대해 논리적으로 값이 맞는 지를 검증하여 하나라도 틀리면 바로 예외를 발생시키기 때문
- 검증 역할 구분
  - 표현 계층 : 필수 값, 값의 형식, 범위 검증
  - 응용 계층 : 논리적 오류 검증
  - 응용 서비스를 실행하는 주체가 다양하면 입력받는 파라미터에 대해 철저한 검증 필요

## 도메인 서비스
- 한 애그리거트 내에서 처리하기 애매한 로직을 처리하기 위해 사용
- 상태없이 로직만 구현
- 애그리거트 객체에 도메인 서비스를 전달하여 애그리거트가 로직을 실행
  - 응용서비스 -> 애그리거트 (파라미터로 도메인 서비스 전달)

## 애그리거트의 트랜잭션 관리
- 다른 트랜잭션에서 같은 애그리거트에 접근하면, 논리적으로는 같지만 물리적으로는 다름
  - 일관성이 깨질수 있는 문제 발생
- 일관성 문제를 해결하기 위한 방법
  1. 선점 잠금
    - DBMS 가 제공하는 행 단위 잠금으로 구현 => for update
    - 교착 상태가 발생할 수 있음 => 최대대기시간을 정하여 해결
    - 사용자와 인터렉션 과정에서 데이터 일관성이 깨질 수 있음
      - 예를 들어, view 세션을 유지하는 경우. 수정에 대한 선점은 트랜잭션 내에서만 처리할 수 있기 때문에, 동시에 같은 애그리거트를 수정하는 경우 문제가 발생
  2. 비선점 잠금
    - 실제 DBMS 반영 시점에 변경가능 여부 확인
      - 애그리거트 버전 정보를 DB에 저장
  3. 오프라인 선점 잠금
    - 다른 트랜잭션이 해당 애그리거트에 대해 오프라인 잠금을 구하면, 그 애그리거트는 수정을 위한 조회부터 막음
      - 잠금 유효시간을 두어 해당 애그리거트가 무한 잠금에 걸리는 것을 방지

## 도메인 모델과 BOUNDED CONTEXT
### BOUNDED CONTEXT
- 구분되는 경계를 갖는 컨텍스트를 뜻함
  - 모델은 특정한 컨텍스트 하에 완전한 의미를 가짐
- 한 개의 모델로 여러 하위 도메인을 모두 표현하려고 하면 하위도메인에 맞지 않는 모델이 생성됨
- 하위 도메인마다 같은 용어라도 의미가 다르고 같은 대상이라도 지칭하는 용어가 다를 수 있음
- 논리적으로 한 개의 모델을 가짐
- 도메인 모델을 구분짓는 경계
- 기업의 조직 규모에 따라 결정되기도 함
- 한 개의 BOUNDED CONTEXT 안에 여러 하위 도메인을 포함시키고(팀 구조에 따라) 패키지를 나누어 하위 도메인을 분리하기도 함
- BOUNDED CONTEXT 는 각자 구현하려는 하위 도메인에 맞는 모델을 가짐
  - 회원 BOUNDED CONTEXT 에서는 Member, 주문 BOUNDED CONTEXT 에서는 Orderer

### 구현
- 도메인 모델뿐만 아니라 표현, 응용, 인프라, DB 등을 모두 포함
- 모든 BOUNDED CONTEXT 를 DDD 로 구현하지 않아도 됨
  - 필요에 따라 DAO 와 밸류 중심 객체로만 구성할 수도 있음
    - CQRS 적용
- UI 서버를 두어 브라우저와 통신(API만 제공)

### BOUNDED CONTEXT 간 통합
- 직접통합 : Rest API 호출
- 간접통합 : 메시지 큐 이용
- Open host Service : 서비스 형태로 api 를 공개 (여러 컴포넌트들이 공통으로 사용가능하도록)
- downstream component -> upstream component 에 의존
  - upstream component 는 공급자 역할
    - 여러 downstream component 에 대응가능해야 함
    - 하위 컴포넌트가 상위 컴포넌트의 도메인 모델에 침투하지 않도록 중간에 인터페이스를 두는 것이 좋음
  - 모델 공유 방식
    1. 공유커널 (shared kernel) : 같은 모델 공유
    2. 독립방식 (separate way) : 중간에 통합시스템을 구축

### 컨텍스트 맵
- 전체 비즈니스를 조망할 수 있는 지도
- 시스템 이해도가 상승하고, 컨텍스트 간 관계가 바뀌면 점점 지도가 바뀜

## 이벤트
- 특정 로직을 처리하다보면 외부의 시스템과 연동될 수도 있음
  - 시스템의 강결합이 생길수 있음 => 이벤트 사용으로 결합도를 낮춤
- 이벤트를 사용함으로서 도메인간의 결합을 낮출 수 있고, 확장에 용이한 구조를 만들기 쉬움
- 메시지 큐 등을 이용하여 이벤트 처리를 할 수 있음

## CQRS
- 조회와 명령에 대한 모델을 분리함으로써 조회 성능을 최적화하고, 모델의 복잡도를 낮출 수 있음
- 트래픽이 많지 않는 서비스에서는 도입 시 개발 생산성 저하가 생길 수 있음