[참고](https://godekdls.github.io/Reactor%20Core/introductiontoreactiveprogramming/)
링크를 읽고 정리한 글

- 리액터는 리액티브 프로그래밍 패러다임의 구현체
# Reactive Programming
## 정의
리액티브 프로그래밍은 데이터 스트림과 변경 사항 전파에 초점을 둔 비동기 프로그래밍 패러다임

## 소개
- RxJava 는 JVM 위에서 실행하는 리액티브 프로그래밍 구현
- 자바 9 부터는 Flow 클래스로 통합
- 옵저버 패턴의 확장으로 사용되기도 함
- Iterable-Iterator 쌍과 성격이 유사 => pull 기반
- Publisher-Subscriber 쌍 => push 기반
  - 새로운 데이터가 있음을 Publisher 가 Subscriber 에게 통지(push)
  - push 받은 데이터에 적용할 연산은 선언형으로 표현
  - **프로그래머는 정확한 제어 흐름을 작성하는 대신 계산 논리를 표현한다**

```onNext x 0..N [onError | onComplete]```
- 이와 같은 접근법을 통해 0..N 개의 데이터를 유연하게 커버한다(N이 무한한 경우도 포함)

## Blocking 의 단점
- 블로킹은 리소스를 낭비
  - I/O 처리가 시작하면 스레드는 데이터를 기다리는 동안 아무일도 하지 않게 되고, 이로 인해 스레드를 많이 사용하는 방법을 사용해야하고, 스레드를 많이 사용하면 결국 컨텍스트 스위칭이 자주 일어나게 되어 cpu 오버헤드를 일으킨다
 
## 자바의 비동기 프로그래밍을 위한 모델
### Callbacks
- 리턴 값은 없지만 결과를 받으면 호출한 callback 파라미터를 추가로 받는 비동기 메소드
- 조합하기가 까다롭고 읽기가 힘들어 유지보수하기 어려운 코드를 만들 가능성이 높음

### Futures
- 곧바로 Future<T> 를 반환하는 비동기메소드. 비동기 프로세스는 T 값을 계산하고, 이를 래핑한 Future 객체로 접근
- Future 객체는 콜백보다 여러 면에서 낫다
  - 코드가 간결하여 알아보기 쉽고 행위를 추가하기도 콜백보다 쉽다
- Future 의 단점
  - get() 메소드를 호출하면 블로킹
  - lazy computation 미지원
  - 멀티 밸류에 대한 지원 부족, 에러 처리 커스텀 어려움

> 리액터는 조합을 위한 연산자가 Future 보다 많기 때문에 코드가 훨씬 간결해짐

## 리액티브 프로그래밍의 특징
- 쉽게 구성할 수 있고, 가독성이 좋음
- 데이터를 풍부한 연산자로 조작할 수 있는 플로우로 표현
- 구독하기 전에는 아무일도 일어나지 않음
- Backpressure : 컨슈머가 프로듀서에게 데이터 생산 속도가 너무 빠르다는 신호를 보낼 수 있음
- 고수준이면서 동시성에 구애받지 않을 정도의 높은 수준의 추상화

