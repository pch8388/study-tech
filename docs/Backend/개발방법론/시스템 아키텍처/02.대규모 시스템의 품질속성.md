# 성능
## 응답시간 (response time)
- 시스템의 성능을 이야기할 때 가장 먼저 떠오르는 지표
- 고객이 요청하고 응답을 받는데 걸린 시간
- Processing time(실행시간) + Waiting Tiem(대기시간, Latency 라고도 함)
   - Latency 를 응답시간을 나타내는 의미로 쓰기도 하고, 응답시간을 End to End Latency 라고 조금 더 세밀하게 표현하기도 함
   - 실행시간은 비즈니스 로직을 처리하는 시간을 이야기 함
   - 대기시간은 네트워크 지연 등으로 인해 대기해야 하는 시간을 이야기 함 => 서버가 처리할 수 있는 요청 수를 넘어선 요청은 대기를 하게 되는 데, 이런 경우도 대기 시간임

## 처리율(Throughput)
- 가장 중요한 성능
- 시스템이 일정 시간 동안 처리한 작업의 양
  - 1초마다 처리한 작업의 수로 측정하기도 함
  - 1초마다 처리한 데이터의 단위(초당 bit, byte, mb 등)으로 측정하기도 함

## 고려사항
### 응답시간
  - 고객이 받는 응답시간을 측정해야함 => 개발자는 Processing Time 만 측정하는 경우가 많음
  - 고객들이 항상 일정한 응답시간을 받지 못하고 대부분은 각각 다른 응답시간을 받게 된다
    - 분산된 응답시간을 분석할 수 있어야 함
    - 평균 응답이 아닌 백분위를 분석해야 함
    - 웅답 시간 샘플을 분류해서 막대 도표에 넣기 - 응답 시간 빈도를 알 수 있도록(응답 시간별 횟수)
      - 부하 분석 도구를 사용하면 볼 수 있는 그래프를 보면 될 것 같음
  - Tail Latency(꼬리 지연 시간) : 다른 값과 비교했을 때 가장 긴 지연 시간이며 응답 시간 중 적은 비율
    - 최대한 짧아야 함
    - Tail Latency을 기준으로 잡고 성능 기준을 세워야 함

### 처리율
  - 부하가 증가하면 성능이 급격히 저하할 수 있음
  - 처리율이 급격히 떨어지는 구간의 원인을 파악해야 함
    - cpu, memory, connections i/o, 소프트웨어 queue 등

# 확장성
시스템에 리소스를 추가하여 증가하는 작업량을 처리하는 시스템의 능력 판단 척도

수직확장, 수평확장, 조직성 확장

## 수직 확장
- 기존 리소스의 성능을 업그레이드
- 장점 : 어떤 앱이든 적용가능, 코드 변경 필요없음, 마이그레이션 간편
- 단점 : 하드웨어 업그레이드는 한계가 있음, 중앙 집중화된 시스템에 국한, 고가용성과 내결함성을 갖출 수 없음

## 수평 확장
- 리소스의 단위를 늘림
- 장점
  - 확장성에 제한이 없음
  - 손쉽게 기기를 추가/제거
  - 고가용성과 내결함성을 갖출 수 있음
- 단점
  - 단일 인스턴스에서 여러 인스턴스를 사용하도록 변경하는 것은 코드를 변경해야 함
  - 복잡도가 올라가고 조정을 위한 오버헤드가 상승

## 조직적 확장
- 일정 수까지는 엔지니어를 추가하여 생산성을 올릴 수 있다
- 특정 규모를 넘어서면 엔지니어를 더 추가하여도 생산성이 향상하지 않을 수 있음
  - 서비스를 나누어 조직별로 서비스를 맡도록 확장할 수 있다

# 가용성
- 사용자가 서비스를 정상적으로 사용, 접근 가능한 시간을 비율로 나타낸 지표
- Availability = uptime / (uptime + downtime)
- MTBF(Mean Time Between Failures) - 평균가동시간
- MTTR(Mean Time to Recovery) - 문제를 발견하고 복구하는 평균 시간(평균중단시간)
- Availability = MTBF / (MTBF + MTTR)
  - 가용성을 측정하기에 더 유용한 공식
  - MTTR 을 0에 가깝게 만들어 가용성을 높일 수 있다
  - 빠른 문제 발견과 복구가 가용성에 영향을 미칠 수 있음

> 사용자가 가용성이 높다고 체감하는 수치 => 일반적으로 99.9% 이상