# 성능
## 응답시간 (response time)
- 시스템의 성능을 이야기할 때 가장 먼저 떠오르는 지표
- 고객이 요청하고 응답을 받는데 걸린 시간
- Processing time(실행시간) + Waiting Tiem(대기시간, Latency 라고도 함)
   - Latency 를 응답시간을 나타내는 의미로 쓰기도 하고, 응답시간을 End to End Latency 라고 조금 더 세밀하게 표현하기도 함
   - 실행시간은 비즈니스 로직을 처리하는 시간을 이야기 함
   - 대기시간은 네트워크 지연 등으로 인해 대기해야 하는 시간을 이야기 함 => 서버가 처리할 수 있는 요청 수를 넘어선 요청은 대기를 하게 되는 데, 이런 경우도 대기 시간임

## 처리율(Throughput)
- 가장 중요한 성능
- 시스템이 일정 시간 동안 처리한 작업의 양
  - 1초마다 처리한 작업의 수로 측정하기도 함
  - 1초마다 처리한 데이터의 단위(초당 bit, byte, mb 등)으로 측정하기도 함

## 고려사항
### 응답시간
  - 고객이 받는 응답시간을 측정해야함 => 개발자는 Processing Time 만 측정하는 경우가 많음
  - 고객들이 항상 일정한 응답시간을 받지 못하고 대부분은 각각 다른 응답시간을 받게 된다
    - 분산된 응답시간을 분석할 수 있어야 함
    - 평균 응답이 아닌 백분위를 분석해야 함
    - 웅답 시간 샘플을 분류해서 막대 도표에 넣기 - 응답 시간 빈도를 알 수 있도록(응답 시간별 횟수)
      - 부하 분석 도구를 사용하면 볼 수 있는 그래프를 보면 될 것 같음
  - Tail Latency(꼬리 지연 시간) : 다른 값과 비교했을 때 가장 긴 지연 시간이며 응답 시간 중 적은 비율
    - 최대한 짧아야 함
    - Tail Latency을 기준으로 잡고 성능 기준을 세워야 함

### 처리율
  - 부하가 증가하면 성능이 급격히 저하할 수 있음
  - 처리율이 급격히 떨어지는 구간의 원인을 파악해야 함
    - cpu, memory, connections i/o, 소프트웨어 queue 등

# 확장성
시스템에 리소스를 추가하여 증가하는 작업량을 처리하는 시스템의 능력 판단 척도

수직확장, 수평확장, 조직성 확장

## 수직 확장
- 기존 리소스의 성능을 업그레이드
- 장점 : 어떤 앱이든 적용가능, 코드 변경 필요없음, 마이그레이션 간편
- 단점 : 하드웨어 업그레이드는 한계가 있음, 중앙 집중화된 시스템에 국한, 고가용성과 내결함성을 갖출 수 없음

## 수평 확장
- 리소스의 단위를 늘림
- 장점
  - 확장성에 제한이 없음
  - 손쉽게 기기를 추가/제거
  - 고가용성과 내결함성을 갖출 수 있음
- 단점
  - 단일 인스턴스에서 여러 인스턴스를 사용하도록 변경하는 것은 코드를 변경해야 함
  - 복잡도가 올라가고 조정을 위한 오버헤드가 상승

## 조직적 확장
- 일정 수까지는 엔지니어를 추가하여 생산성을 올릴 수 있다
- 특정 규모를 넘어서면 엔지니어를 더 추가하여도 생산성이 향상하지 않을 수 있음
  - 서비스를 나누어 조직별로 서비스를 맡도록 확장할 수 있다

# 가용성
- 사용자가 서비스를 정상적으로 사용, 접근 가능한 시간을 비율로 나타낸 지표
- Availability = uptime / (uptime + downtime)
- MTBF(Mean Time Between Failures) - 평균가동시간
- MTTR(Mean Time to Recovery) - 문제를 발견하고 복구하는 평균 시간(평균중단시간)
- Availability = MTBF / (MTBF + MTTR)
  - 가용성을 측정하기에 더 유용한 공식
  - MTTR 을 0에 가깝게 만들어 가용성을 높일 수 있다
  - 빠른 문제 발견과 복구가 가용성에 영향을 미칠 수 있음

> 사용자가 가용성이 높다고 체감하는 수치 => 일반적으로 99.9% 이상(3 nines)

## 서비스가 다운 되는 원인
1. 휴먼 에러
2. 소프트웨어 에러
3. 하드웨어 오류

# 내결함성(Fault Tolerance)
- 오류가 발생하더라도 시스템이 정상적으로 작동하도록 하는 기능
- 내결함성을 이용하여 고가용성을 유지해야 함
  - 시스템이 중단되는 것을 막음

## 내결함성 전략
### 오류 예방
- 복제와 중복 이용
- 액티브-액티브 아키텍처 : 복제를 이용해 모든 레플리카가 요청을 받을 수 있도록 한다
  - 부하를 레플리카 전체에 분산(수평적 확장)
  - 활성화된 모든 레플리카가 동기화 되도록 하는 것이 어려움
- 액티브-패시브 : 모든 요청을 하나의 인스턴스가 받고, 레플리카에 주기적으로 스냅샷 방식 복제
  - 시스템 확장 능력이 낮음
  - 구현이 쉽다
- 공간적 중복성 : 복제를 통해 여러 인스턴스 기동
- 시간적 중복성 : 동일 요청에 대해 성공하거나 포기할때까지 재시도

### 오류 감지와 고립
- 단일 장애지점 제거
  - 결함이 발생한 인스턴스를 감지하고 트래픽이 가는 것을 막음
  - 모니터링 시스템 필요 => 헬스체크, 하트비트 등 이용하여 주기적 체크

### 복구
- 사용자가 알아채기 전에 빠르게 오류가 복구되면 고가용성을 유지할 수 있음
- 문제가 있는 호스트를 격리
  - 트래픽/부하를 막음
  - 호스트 재가동
  - 문제가 없던 이전 상태로 롤백

# SLA - Service Level Agreement
- 서비스 수준 협약
- 서비스 제공자와 클라이언트간의 합의
- 품질 서비스와 관련해 합의를 결정하는 계약 : 법적인 계약

# SLO - Service Level Objectives
- 시스템과 관련해서 설정하는 개별 목표
- 서비스가 달성해야 하는 목표값이나 목표값 범위
  - 품질 속성의 목표같은 것들
- SLA 하나에 여러 SLO가 포함될 수 있음
- SLA 가 없어서 SLO 는 필요함 => 시스템 목표가 있어야 함

# SLI - Service Level Indicators
- 서비스 수준 양적 척도
- 모니터링 시스템을 사용하거나 로그를 사용해 측정한 실제값
